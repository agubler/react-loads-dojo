{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@dojo/framework/shim/global.mjs","webpack:///./node_modules/@dojo/framework/shim/WeakMap.mjs","webpack:///./node_modules/@dojo/framework/core/RegistryHandler.mjs","webpack:///./node_modules/@dojo/framework/core/vdom.mjs","webpack:///./node_modules/@dojo/framework/shim/object.mjs","webpack:///./node_modules/@dojo/framework/shim/Map.mjs","webpack:///./node_modules/@dojo/framework/core/has.mjs","webpack:///./node_modules/@dojo/framework/core/Registry.mjs","webpack:///./node_modules/@dojo/framework/core/Injector.mjs","webpack:///./node_modules/@dojo/framework/core/ThemeInjector.mjs","webpack:///./node_modules/@dojo/framework/core/Destroyable.mjs","webpack:///./node_modules/@dojo/framework/core/Evented.mjs","webpack:///./node_modules/@dojo/framework/shim/Promise.mjs","webpack:///./node_modules/@dojo/framework/shim/Set.mjs","webpack:///./node_modules/@dojo/framework/core/diff.mjs","webpack:///./node_modules/@dojo/framework/shim/support/util.mjs","webpack:///./node_modules/@dojo/framework/shim/array.mjs","webpack:///./node_modules/@dojo/widgets/theme/default/button.m.css.js","webpack:///./node_modules/@dojo/cli-build-widget/template/custom-element.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/@dojo/framework/core/registerCustomElement.mjs","webpack:///./node_modules/@dojo/framework/core/middleware/icache.mjs","webpack:///./node_modules/@dojo/framework/core/middleware/focus.mjs","webpack:///./node_modules/@dojo/widgets/common/util.mjs","webpack:///./node_modules/@dojo/framework/core/middleware/injector.mjs","webpack:///./node_modules/@dojo/framework/core/middleware/theme.mjs","webpack:///./node_modules/@dojo/widgets/middleware/theme.mjs","webpack:///./node_modules/@dojo/widgets/button/index.mjs","webpack:///./src/button-wrapper/ButtonWrapper.tsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","globalObject","window","navigator","userAgent","indexOf","globalThis","self","__webpack_exports__","shim_WeakMap","WeakMap","core_RegistryHandler","Evented","[object Object]","super","this","_registry","Registry","_registryWidgetLabelMap","Map","_registryInjectorLabelMap","own","destroy","baseRegistry","delete","undefined","base","label","widget","define","injector","defineInjector","has","Boolean","hasInjector","globalPrecedence","_get","getFunctionName","labelMap","registries","length","registry","item","registeredLabels","handle","on","event","action","emit","type","set","isTextNode","isWNode","isVNode","w","vdom_dom","tsx","vdom_invalidator","vdom_node","diffProperty","vdom_destroy","getRegistry","vdom_renderer","__rest","e","getOwnPropertySymbols","EMPTY_ARRAY","nodeOperations","NAMESPACE_SVG","NAMESPACE_W3","NAMESPACE_XLINK","WNODE","VNODE","DOMVNODE","scope","__DOJO_SCOPE","setRendering","rendering","nodeType","isWNodeWrapper","child","node","isVNodeWrapper","isVirtualWrapper","tag","isBodyWrapper","wrapper","isHeadWrapper","isSpecialWrapper","isDomVNode","isElementNode","tagName","widgetConstructorOrNode","properties","children","__children__","assign","widgetConstructor","v","propertiesOrChildren","deferredPropertiesCallback","Array","isArray","classes","styles","newProperties","_a","nodeClasses","nodeStyles","nodeProperties","attrs","props","diffType","onAttach","toLowerCase","attributes","events","domNode","text","data","REGISTRY_ITEM","FromRegistry","__properties__","array","Infinity","__autoRegistryItem","buildPreviousProperties","current","deferredProperties","keys","forEach","propName","attrName","getAttribute","reduce","same","dnode1","dnode2","widgetConstructor1","registryItem","widgetConstructor2","props1","props2","instance","every","findIndexOfChild","sameAs","start","createClassPropValue","classNames","className","updateAttribute","attrValue","namespace","setAttributeNS","removeAttribute","setAttribute","arrayFrom","arr","slice","createFactory","callback","middlewares","factory","result","isWidget","middlewareName","middleware","withType","isFactory","returns","widgetInstanceMap","widgetMetaMap","requestedDomNodes","Set","wrapperId","metaId","addNodeToMap","id","widgetMeta","nodeMap","invalidator","destroyHandles","meta","destroyMap","middlewareIds","size","clear","widgetId","split","mountNode","contains","document","body","add","propertyName","propertiesOrDiff","diff","customDiffMap","customDiffProperties","propertyDiffMap","originalProperties","propertiesCalled","console","warn","widgetName","destroyFunction","registryHandler","isDeferred","deferRefs","wrapFunctionProperties","propertyNames","args","unwrap","renderer","_renderScheduled","parentInvalidate","_appWrapperId","_mountOptions","sync","merge","transition","_invalidationQueue","_processQueue","_deferredProcessQueue","_applicationQueue","_eventMap","_idToWrapperMap","_wrapperSiblingMap","_idToChildrenWrappers","_insertBeforeMap","_nodeToWrapperMap","_deferredRenderCallbacks","_allMergedNodes","_deferredProcessIds","nodeOperation","propValue","previousValue","push","updateEvent","eventName","currentValue","previousEvent","removeEventListener","evt","target","addEventListener","removeOrphanedEvents","previousProperties","onlyEvents","isEvent","substr","eventCallback","resolveRegistryItem","owningNode","instanceData","registryLabel","isLazyDefine","renderedToWrapper","rendered","parent","currentParent","requiresInsertBefore","hasPreviousSiblings","depth","wrappedRendered","hasParentWNode","hasVirtualParentNode","hasCurrentParentChildren","insertBefore","previousItem","nodes","pop","mapNodeToInstance","renderedItem","order","parentId","exitAnimation","hasAnimations","nextParent","owningId","runDeferredProperties","next","processProperties","findInsertBefore","searchNode","nextSibling","childDomWrapperId","findDomNodeOnParentWrapper","childWrapper","parentNode","setValue","domValue","onInputValue","onSelectValue","setProperties","currentProperties","nextWrapper","includesEventsAndAttributes","propNames","propCount","previousClassString","currentClassString","merged","domClasses","styleNames","styleCount","j","styleName","newStyleValue","style","lastIndexOf","_createDeferredRenderCallback","callbacks","shift","_scheduleDeferredRenderCallbacks","run","requestAnimationFrame","previousAttributes","attrNames","attrCount","updateAttributes","_schedule","_runInvalidationQueue","getWNodeWrapper","invalidationQueue","previouslyRendered","sort","a","b","_runProcessQueue","sibling","_updateWidget","_runDomInstructionQueue","_cleanUpMergedNodes","mergedNode","removeChild","_process","reverse","parentDomNode","parentElement","enterAnimation","enterAnimationActive","enter","owningWrapper","nodeHandler","inserted","currentDomNode","replaceChild","exitAnimationActive","exit","attached","addRoot","onDetach","distinguishableCheck","childNodes","index","wrappers","parentWNodeWrapper","wrapperToCheck","parentName","nodeIdentifier","checkDistinguishable","createKeyMap","mergeNodes","oldIndex","newIndex","currentLength","nextLength","instructions","replace","currentKeys","nextKeys","currentWrapper","domElement","toUpperCase","mergeNodeIndex","splice","_processMergeNodes","_processOne","dom","currentNode","parentWrapper","findParentDomNode","isVirtual","isBody","isHead","createTextNode","head","createElementNS","createElement","_createDom","invalidate","Constructor","dirty","__setProperties__","__setChildren__","__render__","ids","resolveMiddleware","results","uniqueId","payload","createWidgetOptions","resolvedMiddleware","_createWidget","currentChildren","_updateDom","isSpecial","remove","specialIds","wrapperChildren","_removeDom","processResult","_removeWidget","didRender","customProperties","diffMap","runDiffs","ignoreProperties","core_diff","changed","propertiesDiff","values","childId","mount","mountOptions","renderResult","wrapNodes","siblingId","unmount","cancelAnimationFrame","object_assign","getOwnPropertyDescriptor","getOwnPropertyNames","is","getOwnPropertyDescriptors","entries","_shim_global__WEBPACK_IMPORTED_MODULE_0__","testCache","testFunctions","staticFeatures","DojoHasEnvironment","staticCache","apply","feature","overwrite","normalizedFeature","exists","TypeError","strict","Promise","finally","Animation","KeyframeEffect","AbortController","AbortSignal","IntersectionObserver","ResizeObserver","onpointerdown","Element","WIDGET_BASE_TYPE","isWidgetBaseConstructor","isWidgetFunction","isWNodeFactory","_shim_Promise__WEBPACK_IMPORTED_MODULE_0__","_shim_Map__WEBPACK_IMPORTED_MODULE_1__","_core_Evented__WEBPACK_IMPORTED_MODULE_2__","_type","widgetLabel","_widgetRegistry","Error","toString","then","widgetCtor","emitLoadedEvent","error","injectorFactory","_injectorRegistry","injectorItem","promise","default","isWidgetConstructorDefaultExport","core_Injector","_payload","_invalidator","isThemeWithVariant","theme","isThemeWithVariants","isThemeInjectorPayloadWithVariant","ThemeInjector_ThemeInjector","createThemeInjectorPayload","variant","variants","isVariantModule","noop","resolve","destroyed","Destroyable_Destroyable","handles","_handles","Evented_Evented","regexMap","arguments","listenersMap","methods","globString","targetString","regex","RegExp","test","isGlobMatch","method","listener","map","_addListener","listeners","_global__WEBPACK_IMPORTED_MODULE_0__","_core_has__WEBPACK_IMPORTED_MODULE_1__","ShimPromise","onFinally","reason","auto","_Registry__WEBPACK_IMPORTED_MODULE_0__","isObjectOrArray","reference","previousProperty","newProperty","ignore","validOldProperty","validNewProperty","previousKeys","newKeys","some","shallow","wrapNative","nativeFunction","from","flat","of","copyWithin","fill","find","findIndex","includes","flatMap"," _key","root","pressed","popup","disabled","widgetFactory","registerCustomElement","defaultExport","g","Function","eval","CustomElementChildType","DomToWidgetWrapper","register","_vdom__WEBPACK_IMPORTED_MODULE_1__","_shim_array__WEBPACK_IMPORTED_MODULE_2__","_shim_global__WEBPACK_IMPORTED_MODULE_3__","_ThemeInjector__WEBPACK_IMPORTED_MODULE_4__","RESERVED_PROPS","wrappedWNode","setTimeout","dispatchEvent","CustomEvent","bubbles","detail","options","wrappedDomNode","descriptor","WidgetConstructor","registryFactory","attributeMap","attributeName","HTMLElement","_properties","_children","_eventProperties","_propertiesMap","_initialised","_childType","childType","_waitTillReady","readyState","element","_hasBeenParsed","_readyCallback","domProperties","_propertiesWithAttributes","_attributesToProperties","isReservedProp","filteredPropertyName","_getProperty","_setProperty","_getEventProperty","_setEventProperty","defineProperties","filter","childNode","isElement","isDojoChild","DOJO","NODE","_render","_childConnected","widgetProperties","renderChildren","Wrapper","themeContext","themeRegistry","themeInjector","setInvalidator","registerThemeInjector","_getVariant","_getTheme","_renderer","display","getComputedStyle","dojoce","themes","slots","slotName","slotResult","existingSlotValue","Child","oldValue","parsedValue","JSON","parse","observedAttributes","__customElementDescriptor","customElements","icacheFactory","vdom","cacheMap","api","cachedValue","status","getOrSet","createICacheMiddleware","middleware_icache","focus_icache","focus_focus","icache","focus_factory","currentElement","initialized","previous","nodeSet","onFocusChange","activeElement","_","focus","shouldFocus","Keys","middleware_injector","getInjector","INJECTED_THEME_KEY","middleware_theme","theme_factory","themeKeys","shim_Set","getTheme","themePayload","ThemeInjector","subscribe","css","cachedTheme","currentClasses","currentTheme","classKeys","classKey","join","middleware_theme_factory","coreTheme","uppercaseFirstChar","charAt","middleware_theme_theme","compose","baseCss","prefix","baseKey","variantKey","virtualCss","virtualTheme","variantTheme","baseTheme","prefixedCss","prefixCss","lowercaseFirstChar","trim","constructedTheme","variantComposesClass","widgets_button","button_factory","aria","onClick","onOut","onOver","onDown","onUp","onBlur","onFocus","title","themeCss","button_m_css","idBase","onblur","onclick","stopPropagation","onfocus","onpointerenter","onpointerleave","onpointerup","formatAriaProperties","aria-pressed","ButtonWrapper_factory"],"mappings":"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","file":"button-wrapper-1.0.0.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n","const globalObject = (function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof window !== 'undefined' && window.navigator.userAgent.indexOf('jsdom') > -1) {\n        return window;\n    }\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n})();\nexport default globalObject;\n//# sourceMappingURL=global.mjs.map","import global from './global';\r\nvar isArrayLike = undefined;\r\n// !has('es6-iterator')\r\n// elided: import './iterator'\r\nimport has from '../core/has';\r\n// !has('es6-symbol')\r\n// elided: import './Symbol'\r\nexport let WeakMap = global.WeakMap;\r\nif (!true) {\r\n    const DELETED = {};\r\n    const getUID = function getUID() {\r\n        return Math.floor(Math.random() * 100000000);\r\n    };\r\n    const generateName = (function () {\r\n        let startId = Math.floor(Date.now() % 100000000);\r\n        return function generateName() {\r\n            return '__wm' + getUID() + (startId++ + '__');\r\n        };\r\n    })();\r\n    WeakMap = global.WeakMap = class WeakMap {\r\n        constructor(iterable) {\r\n            this[Symbol.toStringTag] = 'WeakMap';\r\n            this._name = generateName();\r\n            this._frozenEntries = [];\r\n            if (iterable) {\r\n                if (isArrayLike(iterable)) {\r\n                    for (let i = 0; i < iterable.length; i++) {\r\n                        const item = iterable[i];\r\n                        this.set(item[0], item[1]);\r\n                    }\r\n                }\r\n                else {\r\n                    for (const [key, value] of iterable) {\r\n                        this.set(key, value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _getFrozenEntryIndex(key) {\r\n            for (let i = 0; i < this._frozenEntries.length; i++) {\r\n                if (this._frozenEntries[i].key === key) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n        delete(key) {\r\n            if (key === undefined || key === null) {\r\n                return false;\r\n            }\r\n            const entry = key[this._name];\r\n            if (entry && entry.key === key && entry.value !== DELETED) {\r\n                entry.value = DELETED;\r\n                return true;\r\n            }\r\n            const frozenIndex = this._getFrozenEntryIndex(key);\r\n            if (frozenIndex >= 0) {\r\n                this._frozenEntries.splice(frozenIndex, 1);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        get(key) {\r\n            if (key === undefined || key === null) {\r\n                return undefined;\r\n            }\r\n            const entry = key[this._name];\r\n            if (entry && entry.key === key && entry.value !== DELETED) {\r\n                return entry.value;\r\n            }\r\n            const frozenIndex = this._getFrozenEntryIndex(key);\r\n            if (frozenIndex >= 0) {\r\n                return this._frozenEntries[frozenIndex].value;\r\n            }\r\n        }\r\n        has(key) {\r\n            if (key === undefined || key === null) {\r\n                return false;\r\n            }\r\n            const entry = key[this._name];\r\n            if (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\r\n                return true;\r\n            }\r\n            const frozenIndex = this._getFrozenEntryIndex(key);\r\n            if (frozenIndex >= 0) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        set(key, value) {\r\n            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {\r\n                throw new TypeError('Invalid value used as weak map key');\r\n            }\r\n            let entry = key[this._name];\r\n            if (!entry || entry.key !== key) {\r\n                entry = Object.create(null, {\r\n                    key: { value: key }\r\n                });\r\n                if (Object.isFrozen(key)) {\r\n                    this._frozenEntries.push(entry);\r\n                }\r\n                else {\r\n                    Object.defineProperty(key, this._name, {\r\n                        value: entry\r\n                    });\r\n                }\r\n            }\r\n            entry.value = value;\r\n            return this;\r\n        }\r\n    };\r\n}\r\nexport default WeakMap;","import { Map } from '../shim/Map';\r\nimport { Evented } from '../core/Evented';\r\nimport { Registry } from './Registry';\r\nexport class RegistryHandler extends Evented {\r\n    constructor() {\r\n        super();\r\n        this._registry = new Registry();\r\n        this._registryWidgetLabelMap = new Map();\r\n        this._registryInjectorLabelMap = new Map();\r\n        this.own(this._registry);\r\n        const destroy = () => {\r\n            if (this.baseRegistry) {\r\n                this._registryWidgetLabelMap.delete(this.baseRegistry);\r\n                this._registryInjectorLabelMap.delete(this.baseRegistry);\r\n                this.baseRegistry = undefined;\r\n            }\r\n        };\r\n        this.own({ destroy });\r\n    }\r\n    set base(baseRegistry) {\r\n        if (this.baseRegistry) {\r\n            this._registryWidgetLabelMap.delete(this.baseRegistry);\r\n            this._registryInjectorLabelMap.delete(this.baseRegistry);\r\n        }\r\n        this.baseRegistry = baseRegistry;\r\n    }\r\n    get base() {\r\n        return this.baseRegistry;\r\n    }\r\n    define(label, widget) {\r\n        this._registry.define(label, widget);\r\n    }\r\n    defineInjector(label, injector) {\r\n        this._registry.defineInjector(label, injector);\r\n    }\r\n    has(label) {\r\n        return this._registry.has(label) || Boolean(this.baseRegistry && this.baseRegistry.has(label));\r\n    }\r\n    hasInjector(label) {\r\n        return this._registry.hasInjector(label) || Boolean(this.baseRegistry && this.baseRegistry.hasInjector(label));\r\n    }\r\n    get(label, globalPrecedence = false) {\r\n        return this._get(label, globalPrecedence, 'get', this._registryWidgetLabelMap);\r\n    }\r\n    getInjector(label, globalPrecedence = false) {\r\n        return this._get(label, globalPrecedence, 'getInjector', this._registryInjectorLabelMap);\r\n    }\r\n    _get(label, globalPrecedence, getFunctionName, labelMap) {\r\n        const registries = globalPrecedence ? [this.baseRegistry, this._registry] : [this._registry, this.baseRegistry];\r\n        for (let i = 0; i < registries.length; i++) {\r\n            const registry = registries[i];\r\n            if (!registry) {\r\n                continue;\r\n            }\r\n            const item = registry[getFunctionName](label);\r\n            const registeredLabels = labelMap.get(registry) || [];\r\n            if (item) {\r\n                return item;\r\n            }\r\n            else if (registeredLabels.indexOf(label) === -1) {\r\n                const handle = registry.on(label, (event) => {\r\n                    if (event.action === 'loaded' &&\r\n                        this[getFunctionName](label, globalPrecedence) === event.item) {\r\n                        this.emit({ type: 'invalidate' });\r\n                    }\r\n                });\r\n                this.own(handle);\r\n                labelMap.set(registry, [...registeredLabels, label]);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\nexport default RegistryHandler;\r\n//# sourceMappingURL=RegistryHandler.mjs.map","var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n};\r\nimport global from '../shim/global';\r\nimport has from '../core/has';\r\nimport WeakMap from '../shim/WeakMap';\r\nimport Set from '../shim/Set';\r\nimport Map from '../shim/Map';\r\nimport { flat } from '../shim/array';\r\nimport { Registry, isWidget, isWidgetBaseConstructor, isWidgetFunction, isWNodeFactory } from './Registry';\r\nimport { auto } from './diff';\r\nimport RegistryHandler from './RegistryHandler';\r\nconst EMPTY_ARRAY = [];\r\nconst nodeOperations = ['focus', 'blur', 'scrollIntoView', 'click'];\r\nconst NAMESPACE_W3 = 'http://www.w3.org/';\r\nconst NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\r\nconst NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\r\nconst WNODE = '__WNODE_TYPE';\r\nconst VNODE = '__VNODE_TYPE';\r\nconst DOMVNODE = '__DOMVNODE_TYPE';\r\n// @ts-ignore\r\nconst scope = typeof __DOJO_SCOPE === 'string' ? __DOJO_SCOPE : 'dojo_scope';\r\nif (!global[scope]) {\r\n    global[scope] = {};\r\n}\r\nexport function setRendering(value) {\r\n    global[scope].rendering = value;\r\n}\r\nexport function incrementBlockCount() {\r\n    const blocksPending = global[scope].blocksPending || 0;\r\n    global[scope].blocksPending = blocksPending + 1;\r\n}\r\nexport function decrementBlockCount() {\r\n    const blocksPending = global[scope].blocksPending || 0;\r\n    global[scope].blocksPending = blocksPending - 1;\r\n}\r\nexport function isTextNode(item) {\r\n    return item && item.nodeType === 3;\r\n}\r\nfunction isLazyDefine(item) {\r\n    return Boolean(item && item.label);\r\n}\r\nfunction isWNodeWrapper(child) {\r\n    return child && isWNode(child.node);\r\n}\r\nfunction isVNodeWrapper(child) {\r\n    return !!child && isVNode(child.node);\r\n}\r\nfunction isVirtualWrapper(child) {\r\n    return isVNodeWrapper(child) && child.node.tag === 'virtual';\r\n}\r\nfunction isBodyWrapper(wrapper) {\r\n    return isVNodeWrapper(wrapper) && wrapper.node.tag === 'body';\r\n}\r\nfunction isHeadWrapper(wrapper) {\r\n    return isVNodeWrapper(wrapper) && wrapper.node.tag === 'head';\r\n}\r\nfunction isSpecialWrapper(wrapper) {\r\n    return isHeadWrapper(wrapper) || isBodyWrapper(wrapper) || isVirtualWrapper(wrapper);\r\n}\r\nfunction isAttachApplication(value) {\r\n    return !!value.type;\r\n}\r\nexport function isWNode(child) {\r\n    return Boolean(child && child !== true && typeof child !== 'string' && child.type === WNODE);\r\n}\r\nexport function isVNode(child) {\r\n    return Boolean(child && child !== true && typeof child !== 'string' && (child.type === VNODE || child.type === DOMVNODE));\r\n}\r\nexport function isDomVNode(child) {\r\n    return Boolean(child && child !== true && typeof child !== 'string' && child.type === DOMVNODE);\r\n}\r\nexport function isElementNode(value) {\r\n    return !!value.tagName;\r\n}\r\nfunction toTextVNode(data) {\r\n    return {\r\n        tag: '',\r\n        properties: {},\r\n        children: undefined,\r\n        text: `${data}`,\r\n        type: VNODE\r\n    };\r\n}\r\nfunction updateAttributes(domNode, previousAttributes, attributes, namespace) {\r\n    const attrNames = Object.keys(attributes);\r\n    const attrCount = attrNames.length;\r\n    for (let i = 0; i < attrCount; i++) {\r\n        const attrName = attrNames[i];\r\n        const attrValue = attributes[attrName];\r\n        const previousAttrValue = previousAttributes[attrName];\r\n        if (attrValue !== previousAttrValue) {\r\n            updateAttribute(domNode, attrName, attrValue, namespace);\r\n        }\r\n    }\r\n}\r\nexport function w(widgetConstructorOrNode, properties, children) {\r\n    if (properties.__children__) {\r\n        delete properties.__children__;\r\n    }\r\n    if (isWNodeFactory(widgetConstructorOrNode)) {\r\n        return widgetConstructorOrNode(properties, children);\r\n    }\r\n    if (isWNode(widgetConstructorOrNode)) {\r\n        properties = Object.assign({}, widgetConstructorOrNode.properties, properties);\r\n        children = children ? children : widgetConstructorOrNode.children;\r\n        widgetConstructorOrNode = widgetConstructorOrNode.widgetConstructor;\r\n    }\r\n    return {\r\n        children: children || [],\r\n        widgetConstructor: widgetConstructorOrNode,\r\n        properties,\r\n        type: WNODE\r\n    };\r\n}\r\nexport function v(tag, propertiesOrChildren = {}, children = undefined) {\r\n    let properties = propertiesOrChildren;\r\n    let deferredPropertiesCallback;\r\n    if (typeof tag.tag === 'function') {\r\n        return tag.tag(properties, children);\r\n    }\r\n    if (Array.isArray(propertiesOrChildren)) {\r\n        children = propertiesOrChildren;\r\n        properties = {};\r\n    }\r\n    if (typeof properties === 'function') {\r\n        deferredPropertiesCallback = properties;\r\n        properties = {};\r\n    }\r\n    if (isVNode(tag)) {\r\n        let { classes = [], styles = {} } = properties, newProperties = __rest(properties, [\"classes\", \"styles\"]);\r\n        let _a = tag.properties, { classes: nodeClasses = [], styles: nodeStyles = {} } = _a, nodeProperties = __rest(_a, [\"classes\", \"styles\"]);\r\n        nodeClasses = Array.isArray(nodeClasses) ? nodeClasses : [nodeClasses];\r\n        classes = Array.isArray(classes) ? classes : [classes];\r\n        styles = Object.assign({}, nodeStyles, styles);\r\n        properties = Object.assign({}, nodeProperties, newProperties, { classes: [...nodeClasses, ...classes], styles });\r\n        children = children ? children : tag.children;\r\n        tag = tag.tag;\r\n    }\r\n    return {\r\n        tag,\r\n        deferredPropertiesCallback,\r\n        children,\r\n        properties,\r\n        type: VNODE\r\n    };\r\n}\r\n/**\r\n * Create a VNode for an existing DOM Node.\r\n */\r\nexport function dom({ node, attrs = {}, props = {}, on = {}, diffType = 'none', onAttach }, children) {\r\n    return {\r\n        tag: isElementNode(node) ? node.tagName.toLowerCase() : '',\r\n        properties: props,\r\n        attributes: attrs,\r\n        events: on,\r\n        children,\r\n        type: DOMVNODE,\r\n        domNode: node,\r\n        text: isElementNode(node) ? undefined : node.data,\r\n        diffType,\r\n        onAttach\r\n    };\r\n}\r\nexport const REGISTRY_ITEM = '__registry_item';\r\nexport class FromRegistry {\r\n    constructor() {\r\n        /* tslint:disable-next-line:variable-name */\r\n        this.__properties__ = {};\r\n    }\r\n}\r\nFromRegistry.type = REGISTRY_ITEM;\r\nexport function fromRegistry(tag) {\r\n    var _a;\r\n    return _a = class extends FromRegistry {\r\n            constructor() {\r\n                super(...arguments);\r\n                this.properties = {};\r\n                this.name = tag;\r\n            }\r\n        },\r\n        _a.type = REGISTRY_ITEM,\r\n        _a;\r\n}\r\nexport function tsx(tag, properties = {}, ...children) {\r\n    children = flat(children, Infinity);\r\n    properties = properties === null ? {} : properties;\r\n    if (typeof tag === 'string') {\r\n        return v(tag, properties, children);\r\n    }\r\n    else if (tag.type === 'registry' && properties.__autoRegistryItem) {\r\n        const name = properties.__autoRegistryItem;\r\n        delete properties.__autoRegistryItem;\r\n        return w(name, properties, children);\r\n    }\r\n    else if (tag.type === REGISTRY_ITEM) {\r\n        const registryItem = new tag();\r\n        return w(registryItem.name, properties, children);\r\n    }\r\n    else {\r\n        return w(tag, properties, children);\r\n    }\r\n}\r\nexport function propertiesDiff(current, next, invalidator, ignoreProperties) {\r\n    const propertyNames = [...Object.keys(current), ...Object.keys(next)];\r\n    for (let i = 0; i < propertyNames.length; i++) {\r\n        if (ignoreProperties.indexOf(propertyNames[i]) > -1) {\r\n            continue;\r\n        }\r\n        const result = auto(current[propertyNames[i]], next[propertyNames[i]]);\r\n        if (result.changed) {\r\n            invalidator();\r\n            break;\r\n        }\r\n        ignoreProperties.push(propertyNames[i]);\r\n    }\r\n}\r\nfunction buildPreviousProperties(domNode, current) {\r\n    const { node: { diffType, properties, attributes } } = current;\r\n    if (!diffType || diffType === 'vdom') {\r\n        return {\r\n            properties: current.deferredProperties\r\n                ? Object.assign({}, current.deferredProperties, current.node.properties) : current.node.properties,\r\n            attributes: current.node.attributes,\r\n            events: current.node.events\r\n        };\r\n    }\r\n    else if (diffType === 'none') {\r\n        return {\r\n            properties: {},\r\n            attributes: current.node.attributes ? {} : undefined,\r\n            events: current.node.events\r\n        };\r\n    }\r\n    let newProperties = {\r\n        properties: {}\r\n    };\r\n    if (attributes) {\r\n        newProperties.attributes = {};\r\n        newProperties.events = current.node.events;\r\n        Object.keys(properties).forEach((propName) => {\r\n            newProperties.properties[propName] = domNode[propName];\r\n        });\r\n        Object.keys(attributes).forEach((attrName) => {\r\n            newProperties.attributes[attrName] = domNode.getAttribute(attrName);\r\n        });\r\n        return newProperties;\r\n    }\r\n    newProperties.properties = Object.keys(properties).reduce((props, property) => {\r\n        props[property] = domNode.getAttribute(property) || domNode[property];\r\n        return props;\r\n    }, {});\r\n    return newProperties;\r\n}\r\nfunction checkDistinguishable(wrappers, index, parentWNodeWrapper) {\r\n    const wrapperToCheck = wrappers[index];\r\n    if (isVNodeWrapper(wrapperToCheck) && !wrapperToCheck.node.tag) {\r\n        return;\r\n    }\r\n    const { key } = wrapperToCheck.node.properties;\r\n    let parentName = 'unknown';\r\n    if (parentWNodeWrapper) {\r\n        const { node: { widgetConstructor } } = parentWNodeWrapper;\r\n        parentName = widgetConstructor.name || 'unknown';\r\n    }\r\n    if (key === undefined || key === null) {\r\n        for (let i = 0; i < wrappers.length; i++) {\r\n            if (i !== index) {\r\n                const wrapper = wrappers[i];\r\n                if (same(wrapper, wrapperToCheck)) {\r\n                    let nodeIdentifier;\r\n                    if (isWNodeWrapper(wrapper)) {\r\n                        nodeIdentifier = wrapper.node.widgetConstructor.name || 'unknown';\r\n                    }\r\n                    else {\r\n                        nodeIdentifier = wrapper.node.tag;\r\n                    }\r\n                    console.warn(`A widget (${parentName}) has had a child added or removed, but they were not able to uniquely identified. It is recommended to provide a unique 'key' property when using the same widget or element (${nodeIdentifier}) multiple times as siblings`);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction same(dnode1, dnode2) {\r\n    if (isVNodeWrapper(dnode1) && isVNodeWrapper(dnode2)) {\r\n        if (isDomVNode(dnode1.node) && isDomVNode(dnode2.node)) {\r\n            if (dnode1.node.domNode !== dnode2.node.domNode) {\r\n                return false;\r\n            }\r\n        }\r\n        if (dnode1.node.tag !== dnode2.node.tag) {\r\n            return false;\r\n        }\r\n        if (dnode1.node.properties.key !== dnode2.node.properties.key) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    else if (isWNodeWrapper(dnode1) && isWNodeWrapper(dnode2)) {\r\n        const widgetConstructor1 = dnode1.registryItem || dnode1.node.widgetConstructor;\r\n        const widgetConstructor2 = dnode2.registryItem || dnode2.node.widgetConstructor;\r\n        const { node: { properties: props1 } } = dnode1;\r\n        const { node: { properties: props2 } } = dnode2;\r\n        if (dnode1.instance === undefined && typeof widgetConstructor2 === 'string') {\r\n            return false;\r\n        }\r\n        if (widgetConstructor1 !== widgetConstructor2) {\r\n            return false;\r\n        }\r\n        if (props1.key !== props2.key) {\r\n            return false;\r\n        }\r\n        if (!(widgetConstructor1.keys || []).every((key) => props1[key] === props2[key])) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction findIndexOfChild(children, sameAs, start) {\r\n    for (let i = start; i < children.length; i++) {\r\n        if (same(children[i], sameAs)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction createClassPropValue(classes = []) {\r\n    let classNames = '';\r\n    if (Array.isArray(classes)) {\r\n        for (let i = 0; i < classes.length; i++) {\r\n            let className = classes[i];\r\n            if (className && className !== true) {\r\n                classNames = classNames ? `${classNames} ${className}` : className;\r\n            }\r\n        }\r\n        return classNames;\r\n    }\r\n    if (classes && classes !== true) {\r\n        classNames = classes;\r\n    }\r\n    return classNames;\r\n}\r\nfunction updateAttribute(domNode, attrName, attrValue, namespace) {\r\n    if (namespace === NAMESPACE_SVG && attrName === 'href' && attrValue) {\r\n        domNode.setAttributeNS(NAMESPACE_XLINK, attrName, attrValue);\r\n    }\r\n    else if ((attrName === 'role' && attrValue === '') || attrValue === undefined) {\r\n        domNode.removeAttribute(attrName);\r\n    }\r\n    else {\r\n        domNode.setAttribute(attrName, attrValue);\r\n    }\r\n}\r\nfunction arrayFrom(arr) {\r\n    return Array.prototype.slice.call(arr);\r\n}\r\nfunction createFactory(callback, middlewares, key) {\r\n    const factory = (properties, children) => {\r\n        if (properties) {\r\n            const result = w(callback, properties, children);\r\n            callback.isWidget = true;\r\n            callback.middlewares = middlewares;\r\n            return result;\r\n        }\r\n        return {\r\n            middlewares,\r\n            callback\r\n        };\r\n    };\r\n    const keys = Object.keys(middlewares).reduce((keys, middlewareName) => {\r\n        const middleware = middlewares[middlewareName];\r\n        if (middleware.keys) {\r\n            keys = [...keys, ...middleware.keys];\r\n        }\r\n        return keys;\r\n    }, key ? [key] : []);\r\n    factory.withType = () => {\r\n        return factory;\r\n    };\r\n    callback.keys = keys;\r\n    factory.keys = keys;\r\n    factory.isFactory = true;\r\n    return factory;\r\n}\r\nexport function create(middlewares = {}) {\r\n    function properties() {\r\n        function returns(callback) {\r\n            return createFactory(callback, middlewares);\r\n        }\r\n        function key(key) {\r\n            function returns(callback) {\r\n                return createFactory(callback, middlewares, key);\r\n            }\r\n            return returns;\r\n        }\r\n        function children() {\r\n            function returns(callback) {\r\n                return createFactory(callback, middlewares);\r\n            }\r\n            function key(key) {\r\n                function returns(callback) {\r\n                    return createFactory(callback, middlewares, key);\r\n                }\r\n                return returns;\r\n            }\r\n            returns.key = key;\r\n            return returns;\r\n        }\r\n        returns.children = children;\r\n        returns.key = key;\r\n        return returns;\r\n    }\r\n    function children() {\r\n        function properties() {\r\n            function returns(callback) {\r\n                return createFactory(callback, middlewares);\r\n            }\r\n            function key(key) {\r\n                function returns(callback) {\r\n                    return createFactory(callback, middlewares, key);\r\n                }\r\n                return returns;\r\n            }\r\n            returns.key = key;\r\n            return returns;\r\n        }\r\n        function returns(callback) {\r\n            return createFactory(callback, middlewares);\r\n        }\r\n        returns.properties = properties;\r\n        return returns;\r\n    }\r\n    function returns(callback) {\r\n        return createFactory(callback, middlewares);\r\n    }\r\n    returns.children = children;\r\n    returns.properties = properties;\r\n    return returns;\r\n}\r\nconst factory = create();\r\nfunction wrapNodes(renderer) {\r\n    const result = renderer();\r\n    const isWNodeWrapper = isWNode(result);\r\n    const callback = () => {\r\n        return result;\r\n    };\r\n    callback.isWNodeWrapper = isWNodeWrapper;\r\n    return factory(callback);\r\n}\r\nexport const widgetInstanceMap = new WeakMap();\r\nconst widgetMetaMap = new Map();\r\nconst requestedDomNodes = new Set();\r\nlet wrapperId = 0;\r\nlet metaId = 0;\r\nfunction addNodeToMap(id, key, node) {\r\n    const widgetMeta = widgetMetaMap.get(id);\r\n    if (widgetMeta) {\r\n        widgetMeta.nodeMap = widgetMeta.nodeMap || new Map();\r\n        widgetMeta.nodeMap.set(key, node);\r\n        if (requestedDomNodes.has(`${id}-${key}`)) {\r\n            widgetMeta.invalidator();\r\n            requestedDomNodes.delete(`${id}-${key}`);\r\n        }\r\n    }\r\n}\r\nfunction destroyHandles(meta) {\r\n    const { destroyMap, middlewareIds } = meta;\r\n    if (!destroyMap) {\r\n        return;\r\n    }\r\n    for (let i = 0; i < middlewareIds.length; i++) {\r\n        const id = middlewareIds[i];\r\n        const destroy = destroyMap.get(id);\r\n        destroy && destroy();\r\n        destroyMap.delete(id);\r\n        if (destroyMap.size === 0) {\r\n            break;\r\n        }\r\n    }\r\n    destroyMap.clear();\r\n}\r\nfunction runDiffs(meta, current, next) {\r\n    let customProperties = {};\r\n    meta.customDiffMap = meta.customDiffMap || new Map();\r\n    if (meta.customDiffMap.size) {\r\n        meta.customDiffMap.forEach((diffMap) => {\r\n            diffMap.forEach((diff, propertyName) => {\r\n                const result = diff(Object.assign({}, current), Object.assign({}, next));\r\n                if (result) {\r\n                    customProperties[propertyName] = result;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    return customProperties;\r\n}\r\nexport const invalidator = factory(({ id }) => {\r\n    const [widgetId] = id.split('-');\r\n    return () => {\r\n        const widgetMeta = widgetMetaMap.get(widgetId);\r\n        if (widgetMeta) {\r\n            return widgetMeta.invalidator();\r\n        }\r\n    };\r\n});\r\nexport const node = factory(({ id }) => {\r\n    return {\r\n        get(key) {\r\n            const [widgetId] = id.split('-');\r\n            const widgetMeta = widgetMetaMap.get(widgetId);\r\n            if (widgetMeta) {\r\n                widgetMeta.nodeMap = widgetMeta.nodeMap || new Map();\r\n                const mountNode = widgetMeta.mountNode;\r\n                const node = widgetMeta.nodeMap.get(key);\r\n                if (node &&\r\n                    (mountNode.contains(node) ||\r\n                        (global.document.body !== mountNode && global.document.body.contains(node)))) {\r\n                    return node;\r\n                }\r\n                requestedDomNodes.add(`${widgetId}-${key}`);\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n});\r\nexport const diffProperty = factory(({ id }) => {\r\n    function callback(propertyName, propertiesOrDiff, diff) {\r\n        const [widgetId] = id.split('-');\r\n        const widgetMeta = widgetMetaMap.get(widgetId);\r\n        if (!diff) {\r\n            diff = propertiesOrDiff;\r\n        }\r\n        if (widgetMeta) {\r\n            widgetMeta.customDiffMap = widgetMeta.customDiffMap || new Map();\r\n            widgetMeta.customDiffProperties = widgetMeta.customDiffProperties || new Set();\r\n            const propertyDiffMap = widgetMeta.customDiffMap.get(id) || new Map();\r\n            if (!propertyDiffMap.has(propertyName)) {\r\n                const result = diff({}, widgetMeta.originalProperties);\r\n                if (result !== undefined) {\r\n                    if (has('dojo-debug')) {\r\n                        if (widgetMeta.propertiesCalled) {\r\n                            console.warn(`Calling \"propertyDiff\" middleware after accessing properties in \"${widgetMeta.widgetName}\", can result in referencing stale properties.`);\r\n                        }\r\n                    }\r\n                    widgetMeta.properties = Object.assign({}, widgetMeta.properties, { [propertyName]: result });\r\n                }\r\n                propertyDiffMap.set(propertyName, diff);\r\n                widgetMeta.customDiffProperties.add(propertyName);\r\n            }\r\n            widgetMeta.customDiffMap.set(id, propertyDiffMap);\r\n        }\r\n    }\r\n    return callback;\r\n});\r\nexport const destroy = factory(({ id }) => {\r\n    return (destroyFunction) => {\r\n        const [widgetId] = id.split('-');\r\n        const widgetMeta = widgetMetaMap.get(widgetId);\r\n        if (widgetMeta) {\r\n            widgetMeta.destroyMap = widgetMeta.destroyMap || new Map();\r\n            if (!widgetMeta.destroyMap.has(id)) {\r\n                widgetMeta.destroyMap.set(id, destroyFunction);\r\n            }\r\n        }\r\n    };\r\n});\r\nexport const getRegistry = factory(({ id }) => {\r\n    const [widgetId] = id.split('-');\r\n    return () => {\r\n        const widgetMeta = widgetMetaMap.get(widgetId);\r\n        if (widgetMeta) {\r\n            if (!widgetMeta.registryHandler) {\r\n                widgetMeta.registryHandler = new RegistryHandler();\r\n                widgetMeta.registryHandler.base = widgetMeta.registry;\r\n                widgetMeta.registryHandler.on('invalidate', widgetMeta.invalidator);\r\n            }\r\n            widgetMeta.registryHandler = widgetMeta.registryHandler || new RegistryHandler();\r\n            return widgetMeta.registryHandler;\r\n        }\r\n        return null;\r\n    };\r\n});\r\nexport const defer = factory(({ id }) => {\r\n    const [widgetId] = id.split('-');\r\n    let isDeferred = false;\r\n    return {\r\n        pause() {\r\n            const widgetMeta = widgetMetaMap.get(widgetId);\r\n            if (!isDeferred && widgetMeta) {\r\n                widgetMeta.deferRefs = widgetMeta.deferRefs + 1;\r\n                isDeferred = true;\r\n            }\r\n        },\r\n        resume() {\r\n            const widgetMeta = widgetMetaMap.get(widgetId);\r\n            if (isDeferred && widgetMeta) {\r\n                widgetMeta.deferRefs = widgetMeta.deferRefs - 1;\r\n                isDeferred = false;\r\n            }\r\n        }\r\n    };\r\n});\r\nfunction wrapFunctionProperties(id, properties) {\r\n    const props = {};\r\n    const propertyNames = Object.keys(properties);\r\n    for (let i = 0; i < propertyNames.length; i++) {\r\n        const propertyName = propertyNames[i];\r\n        if (typeof properties[propertyName] === 'function') {\r\n            props[propertyName] = function WrappedProperty(...args) {\r\n                const widgetMeta = widgetMetaMap.get(id);\r\n                if (widgetMeta) {\r\n                    return widgetMeta.originalProperties[propertyName](...args);\r\n                }\r\n                return properties[propertyName](...args);\r\n            };\r\n            props[propertyName].unwrap = () => {\r\n                const widgetMeta = widgetMetaMap.get(id);\r\n                if (widgetMeta) {\r\n                    return widgetMeta.originalProperties[propertyName];\r\n                }\r\n                return properties[propertyName];\r\n            };\r\n        }\r\n        else {\r\n            props[propertyName] = properties[propertyName];\r\n        }\r\n    }\r\n    return props;\r\n}\r\nexport function renderer(renderer) {\r\n    let _mountOptions = {\r\n        sync: false,\r\n        merge: true,\r\n        transition: undefined,\r\n        domNode: global.document.body,\r\n        registry: new Registry()\r\n    };\r\n    let _invalidationQueue = [];\r\n    let _processQueue = [];\r\n    let _deferredProcessQueue = [];\r\n    let _applicationQueue = [];\r\n    let _eventMap = new WeakMap();\r\n    let _idToWrapperMap = new Map();\r\n    let _wrapperSiblingMap = new WeakMap();\r\n    let _idToChildrenWrappers = new Map();\r\n    let _insertBeforeMap = new WeakMap();\r\n    let _nodeToWrapperMap = new WeakMap();\r\n    let _renderScheduled;\r\n    let _deferredRenderCallbacks = [];\r\n    let parentInvalidate;\r\n    let _allMergedNodes = [];\r\n    let _appWrapperId;\r\n    let _deferredProcessIds = new Map();\r\n    function nodeOperation(propName, propValue, previousValue, domNode) {\r\n        let result = propValue && !previousValue;\r\n        if (typeof propValue === 'function') {\r\n            result = propValue();\r\n        }\r\n        if (result === true) {\r\n            _deferredRenderCallbacks.push(() => {\r\n                domNode[propName]();\r\n            });\r\n        }\r\n    }\r\n    function updateEvent(domNode, eventName, currentValue, previousValue) {\r\n        if (previousValue) {\r\n            const previousEvent = _eventMap.get(previousValue);\r\n            previousEvent && domNode.removeEventListener(eventName, previousEvent);\r\n        }\r\n        let callback = currentValue;\r\n        if (eventName === 'input') {\r\n            callback = function (evt) {\r\n                currentValue.call(this, evt);\r\n                evt.target['oninput-value'] = evt.target.value;\r\n            };\r\n        }\r\n        domNode.addEventListener(eventName, callback);\r\n        _eventMap.set(currentValue, callback);\r\n    }\r\n    function removeOrphanedEvents(domNode, previousProperties, properties, onlyEvents = false) {\r\n        Object.keys(previousProperties).forEach((propName) => {\r\n            const isEvent = propName.substr(0, 2) === 'on' || onlyEvents;\r\n            const eventName = onlyEvents ? propName : propName.substr(2);\r\n            if (isEvent && !properties[propName]) {\r\n                const eventCallback = _eventMap.get(previousProperties[propName]);\r\n                if (eventCallback) {\r\n                    domNode.removeEventListener(eventName, eventCallback);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    function resolveRegistryItem(wrapper, instance, id) {\r\n        if (!isWidget(wrapper.node.widgetConstructor)) {\r\n            const owningNode = _nodeToWrapperMap.get(wrapper.node);\r\n            if (owningNode) {\r\n                if (owningNode.instance) {\r\n                    instance = owningNode.instance;\r\n                }\r\n                else {\r\n                    id = owningNode.id;\r\n                }\r\n            }\r\n            let registry;\r\n            if (instance) {\r\n                const instanceData = widgetInstanceMap.get(instance);\r\n                if (instanceData) {\r\n                    registry = instanceData.registry;\r\n                }\r\n            }\r\n            else if (id !== undefined) {\r\n                const widgetMeta = widgetMetaMap.get(id);\r\n                if (widgetMeta) {\r\n                    if (!widgetMeta.registryHandler) {\r\n                        widgetMeta.registryHandler = new RegistryHandler();\r\n                        widgetMeta.registryHandler.base = widgetMeta.registry;\r\n                        widgetMeta.registryHandler.on('invalidate', widgetMeta.invalidator);\r\n                    }\r\n                    registry = widgetMeta.registryHandler;\r\n                }\r\n            }\r\n            if (registry) {\r\n                let registryLabel;\r\n                if (isLazyDefine(wrapper.node.widgetConstructor)) {\r\n                    const { label, registryItem } = wrapper.node.widgetConstructor;\r\n                    if (!registry.has(label)) {\r\n                        registry.define(label, registryItem);\r\n                    }\r\n                    registryLabel = label;\r\n                }\r\n                else {\r\n                    registryLabel = wrapper.node.widgetConstructor;\r\n                }\r\n                let item = registry.get(registryLabel);\r\n                if (isWNodeFactory(item)) {\r\n                    const node = item(wrapper.node.properties, wrapper.node.children);\r\n                    if (isWidgetFunction(node.widgetConstructor)) {\r\n                        wrapper.registryItem = node.widgetConstructor;\r\n                    }\r\n                }\r\n                else {\r\n                    wrapper.registryItem = item;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function mapNodeToInstance(nodes, wrapper) {\r\n        while (nodes.length) {\r\n            let node = nodes.pop();\r\n            if (isWNode(node) || isVNode(node)) {\r\n                if (!_nodeToWrapperMap.has(node)) {\r\n                    _nodeToWrapperMap.set(node, wrapper);\r\n                    if (node.children && node.children.length) {\r\n                        nodes = [...nodes, ...node.children];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function renderedToWrapper(rendered, parent, currentParent) {\r\n        const { requiresInsertBefore, hasPreviousSiblings, namespace, depth } = parent;\r\n        const wrappedRendered = [];\r\n        const hasParentWNode = isWNodeWrapper(parent);\r\n        const hasVirtualParentNode = isVirtualWrapper(parent);\r\n        const currentParentChildren = (isVNodeWrapper(currentParent) && _idToChildrenWrappers.get(currentParent.id)) || [];\r\n        const hasCurrentParentChildren = currentParentChildren.length > 0;\r\n        const insertBefore = ((requiresInsertBefore || hasPreviousSiblings !== false) && (hasParentWNode || hasVirtualParentNode)) ||\r\n            (hasCurrentParentChildren && rendered.length > 1);\r\n        let previousItem;\r\n        if (isWNodeWrapper(parent) && rendered.length) {\r\n            mapNodeToInstance([...rendered], parent);\r\n        }\r\n        for (let i = 0; i < rendered.length; i++) {\r\n            let renderedItem = rendered[i];\r\n            if (!renderedItem || renderedItem === true) {\r\n                continue;\r\n            }\r\n            if (typeof renderedItem === 'string') {\r\n                renderedItem = toTextVNode(renderedItem);\r\n            }\r\n            const owningNode = _nodeToWrapperMap.get(renderedItem);\r\n            const wrapper = {\r\n                node: renderedItem,\r\n                depth: depth + 1,\r\n                order: i,\r\n                parentId: parent.id,\r\n                requiresInsertBefore: insertBefore,\r\n                hasParentWNode,\r\n                namespace: namespace\r\n            };\r\n            if (isVNode(renderedItem)) {\r\n                if (renderedItem.deferredPropertiesCallback) {\r\n                    wrapper.deferredProperties = renderedItem.deferredPropertiesCallback(false);\r\n                }\r\n                if (renderedItem.properties.exitAnimation) {\r\n                    parent.hasAnimations = true;\r\n                    let nextParent = _idToWrapperMap.get(parent.parentId);\r\n                    while (nextParent) {\r\n                        if (nextParent.hasAnimations) {\r\n                            break;\r\n                        }\r\n                        nextParent.hasAnimations = true;\r\n                        nextParent = _idToWrapperMap.get(nextParent.parentId);\r\n                    }\r\n                }\r\n            }\r\n            if (owningNode) {\r\n                wrapper.owningId = owningNode.id;\r\n            }\r\n            if (isWNode(renderedItem)) {\r\n                resolveRegistryItem(wrapper, parent.instance, parent.id);\r\n            }\r\n            if (previousItem) {\r\n                _wrapperSiblingMap.set(previousItem, wrapper);\r\n            }\r\n            wrappedRendered.push(wrapper);\r\n            previousItem = wrapper;\r\n        }\r\n        return wrappedRendered;\r\n    }\r\n    function findParentDomNode(currentNode) {\r\n        let parentDomNode;\r\n        let parentWrapper = _idToWrapperMap.get(currentNode.parentId);\r\n        while (!parentDomNode && parentWrapper) {\r\n            if (!parentDomNode &&\r\n                isVNodeWrapper(parentWrapper) &&\r\n                !isVirtualWrapper(parentWrapper) &&\r\n                parentWrapper.domNode) {\r\n                parentDomNode = parentWrapper.domNode;\r\n            }\r\n            parentWrapper = _idToWrapperMap.get(parentWrapper.parentId);\r\n        }\r\n        return parentDomNode;\r\n    }\r\n    function runDeferredProperties(next) {\r\n        const { deferredPropertiesCallback } = next.node;\r\n        if (deferredPropertiesCallback) {\r\n            const properties = next.node.properties;\r\n            _deferredRenderCallbacks.push(() => {\r\n                if (_idToWrapperMap.has(next.owningId)) {\r\n                    const deferredProperties = next.deferredProperties;\r\n                    next.deferredProperties = deferredPropertiesCallback(true);\r\n                    processProperties(next, {\r\n                        properties: Object.assign({}, deferredProperties, properties)\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    function findInsertBefore(next) {\r\n        let insertBefore = null;\r\n        let searchNode = next;\r\n        while (!insertBefore) {\r\n            const nextSibling = _wrapperSiblingMap.get(searchNode);\r\n            if (nextSibling) {\r\n                if (isBodyWrapper(nextSibling) || isHeadWrapper(nextSibling)) {\r\n                    searchNode = nextSibling;\r\n                    continue;\r\n                }\r\n                let domNode = nextSibling.domNode;\r\n                if (isWNodeWrapper(nextSibling) || isVirtualWrapper(nextSibling)) {\r\n                    if (!nextSibling.childDomWrapperId) {\r\n                        nextSibling.childDomWrapperId = findDomNodeOnParentWrapper(nextSibling.id);\r\n                    }\r\n                    if (nextSibling.childDomWrapperId) {\r\n                        const childWrapper = _idToWrapperMap.get(nextSibling.childDomWrapperId);\r\n                        if (childWrapper && !isBodyWrapper(childWrapper) && !isHeadWrapper(childWrapper)) {\r\n                            domNode = childWrapper.domNode;\r\n                        }\r\n                    }\r\n                }\r\n                if (domNode && domNode.parentNode) {\r\n                    insertBefore = domNode;\r\n                    break;\r\n                }\r\n                searchNode = nextSibling;\r\n                continue;\r\n            }\r\n            searchNode = searchNode && _idToWrapperMap.get(searchNode.parentId);\r\n            if (!searchNode || (isVNodeWrapper(searchNode) && !isVirtualWrapper(searchNode))) {\r\n                break;\r\n            }\r\n        }\r\n        return insertBefore;\r\n    }\r\n    function setValue(domNode, propValue, previousValue) {\r\n        const domValue = domNode.value;\r\n        const onInputValue = domNode['oninput-value'];\r\n        const onSelectValue = domNode['select-value'];\r\n        if (onSelectValue && domValue !== onSelectValue) {\r\n            domNode.value = onSelectValue;\r\n            if (domNode.value === onSelectValue) {\r\n                domNode['select-value'] = undefined;\r\n            }\r\n        }\r\n        else if ((onInputValue && domValue === onInputValue) || propValue !== previousValue) {\r\n            domNode.value = propValue;\r\n            domNode['oninput-value'] = undefined;\r\n        }\r\n    }\r\n    function setProperties(domNode, currentProperties = {}, nextWrapper, includesEventsAndAttributes = true) {\r\n        const properties = nextWrapper.deferredProperties\r\n            ? Object.assign({}, nextWrapper.deferredProperties, nextWrapper.node.properties) : nextWrapper.node.properties;\r\n        const propNames = Object.keys(properties);\r\n        const propCount = propNames.length;\r\n        if (propNames.indexOf('classes') === -1 && currentProperties.classes) {\r\n            domNode.removeAttribute('class');\r\n        }\r\n        includesEventsAndAttributes && removeOrphanedEvents(domNode, currentProperties, properties);\r\n        for (let i = 0; i < propCount; i++) {\r\n            const propName = propNames[i];\r\n            let propValue = properties[propName];\r\n            const previousValue = currentProperties[propName];\r\n            if (propName === 'classes') {\r\n                const previousClassString = createClassPropValue(previousValue);\r\n                let currentClassString = createClassPropValue(propValue);\r\n                if (previousClassString !== currentClassString) {\r\n                    if (currentClassString) {\r\n                        if (nextWrapper.merged) {\r\n                            const domClasses = (domNode.getAttribute('class') || '').split(' ');\r\n                            for (let i = 0; i < domClasses.length; i++) {\r\n                                if (currentClassString.indexOf(domClasses[i]) === -1) {\r\n                                    currentClassString = `${domClasses[i]} ${currentClassString}`;\r\n                                }\r\n                            }\r\n                        }\r\n                        domNode.setAttribute('class', currentClassString);\r\n                    }\r\n                    else {\r\n                        domNode.removeAttribute('class');\r\n                    }\r\n                }\r\n            }\r\n            else if (nodeOperations.indexOf(propName) !== -1) {\r\n                nodeOperation(propName, propValue, previousValue, domNode);\r\n            }\r\n            else if (propName === 'styles') {\r\n                const styleNames = Object.keys(propValue);\r\n                const styleCount = styleNames.length;\r\n                for (let j = 0; j < styleCount; j++) {\r\n                    const styleName = styleNames[j];\r\n                    const newStyleValue = propValue[styleName];\r\n                    const oldStyleValue = previousValue && previousValue[styleName];\r\n                    if (newStyleValue === oldStyleValue) {\r\n                        continue;\r\n                    }\r\n                    domNode.style[styleName] = newStyleValue || '';\r\n                }\r\n            }\r\n            else {\r\n                if (!propValue && typeof previousValue === 'string') {\r\n                    propValue = '';\r\n                }\r\n                if (propName === 'value') {\r\n                    if (domNode.tagName === 'SELECT') {\r\n                        domNode['select-value'] = propValue;\r\n                    }\r\n                    setValue(domNode, propValue, previousValue);\r\n                }\r\n                else if (propName !== 'key' && propValue !== previousValue) {\r\n                    const type = typeof propValue;\r\n                    if (type === 'function' && propName.lastIndexOf('on', 0) === 0 && includesEventsAndAttributes) {\r\n                        updateEvent(domNode, propName.substr(2), propValue, previousValue);\r\n                    }\r\n                    else if (type === 'string' && propName !== 'innerHTML' && includesEventsAndAttributes) {\r\n                        updateAttribute(domNode, propName, propValue, nextWrapper.namespace);\r\n                    }\r\n                    else if (propName === 'scrollLeft' || propName === 'scrollTop') {\r\n                        if (domNode[propName] !== propValue) {\r\n                            domNode[propName] = propValue;\r\n                        }\r\n                    }\r\n                    else {\r\n                        domNode[propName] = propValue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function _createDeferredRenderCallback() {\r\n        const callbacks = _deferredRenderCallbacks;\r\n        _deferredRenderCallbacks = [];\r\n        if (callbacks.length) {\r\n            return () => {\r\n                let callback;\r\n                while ((callback = callbacks.shift())) {\r\n                    callback();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    function _scheduleDeferredRenderCallbacks() {\r\n        const { sync } = _mountOptions;\r\n        const run = _createDeferredRenderCallback();\r\n        if (run) {\r\n            if (sync) {\r\n                run();\r\n            }\r\n            else {\r\n                let id;\r\n                id = global.requestAnimationFrame(() => {\r\n                    _deferredProcessIds.delete(id);\r\n                    run();\r\n                });\r\n                _deferredProcessIds.set(id, run);\r\n            }\r\n        }\r\n    }\r\n    function processProperties(next, previousProperties) {\r\n        if (next.node.attributes && next.node.events) {\r\n            updateAttributes(next.domNode, previousProperties.attributes || {}, next.node.attributes, next.namespace);\r\n            setProperties(next.domNode, previousProperties.properties, next, false);\r\n            const events = next.node.events || {};\r\n            if (previousProperties.events) {\r\n                removeOrphanedEvents(next.domNode, previousProperties.events || {}, next.node.events, true);\r\n            }\r\n            previousProperties.events = previousProperties.events || {};\r\n            Object.keys(events).forEach((event) => {\r\n                updateEvent(next.domNode, event, events[event], previousProperties.events[event]);\r\n            });\r\n        }\r\n        else {\r\n            setProperties(next.domNode, previousProperties.properties, next);\r\n        }\r\n    }\r\n    function unmount() {\r\n        _processQueue.push({\r\n            current: [_idToWrapperMap.get(_appWrapperId)],\r\n            next: [],\r\n            meta: {}\r\n        });\r\n        if (_renderScheduled) {\r\n            global.cancelAnimationFrame(_renderScheduled);\r\n        }\r\n        _runProcessQueue();\r\n        _runDomInstructionQueue();\r\n        _deferredProcessIds.forEach((callback, id) => {\r\n            global.cancelAnimationFrame(id);\r\n            callback();\r\n        });\r\n        const run = _createDeferredRenderCallback();\r\n        run && run();\r\n        _invalidationQueue = [];\r\n        _processQueue = [];\r\n        _deferredProcessQueue = [];\r\n        _applicationQueue = [];\r\n        _deferredRenderCallbacks = [];\r\n        _allMergedNodes = [];\r\n        _eventMap = new WeakMap();\r\n        _idToWrapperMap.clear();\r\n        _idToChildrenWrappers.clear();\r\n        _wrapperSiblingMap = new WeakMap();\r\n        _nodeToWrapperMap = new WeakMap();\r\n        _insertBeforeMap = undefined;\r\n    }\r\n    function mount(mountOptions = {}) {\r\n        let domNode = mountOptions.domNode;\r\n        if (!domNode) {\r\n            if (has('dojo-debug') && domNode === null) {\r\n                console.warn('Unable to find node to mount the application, defaulting to the document body.');\r\n            }\r\n            domNode = global.document.body;\r\n        }\r\n        _mountOptions = Object.assign({}, _mountOptions, mountOptions, { domNode });\r\n        const renderResult = wrapNodes(renderer)({}, []);\r\n        _appWrapperId = `${wrapperId++}`;\r\n        const nextWrapper = {\r\n            id: _appWrapperId,\r\n            node: renderResult,\r\n            order: 0,\r\n            depth: 1,\r\n            owningId: '-1',\r\n            parentId: '-1',\r\n            siblingId: '-1',\r\n            properties: {}\r\n        };\r\n        _idToWrapperMap.set('-1', {\r\n            id: `-1`,\r\n            depth: 0,\r\n            order: 0,\r\n            owningId: '',\r\n            domNode,\r\n            node: v('fake'),\r\n            parentId: '-1'\r\n        });\r\n        _processQueue.push({\r\n            current: [],\r\n            next: [nextWrapper],\r\n            meta: { mergeNodes: arrayFrom(domNode.childNodes) }\r\n        });\r\n        _runProcessQueue();\r\n        _runDomInstructionQueue();\r\n        _cleanUpMergedNodes();\r\n        _insertBeforeMap = undefined;\r\n        _scheduleDeferredRenderCallbacks();\r\n        if (!_renderScheduled) {\r\n            setRendering(false);\r\n        }\r\n    }\r\n    function invalidate() {\r\n        parentInvalidate && parentInvalidate();\r\n    }\r\n    function _schedule() {\r\n        const { sync } = _mountOptions;\r\n        if (sync) {\r\n            _runInvalidationQueue();\r\n        }\r\n        else if (!_renderScheduled) {\r\n            setRendering(true);\r\n            _renderScheduled = global.requestAnimationFrame(() => {\r\n                _runInvalidationQueue();\r\n            });\r\n        }\r\n    }\r\n    function getWNodeWrapper(id) {\r\n        const wrapper = _idToWrapperMap.get(id);\r\n        if (wrapper && isWNodeWrapper(wrapper)) {\r\n            return wrapper;\r\n        }\r\n    }\r\n    function _runInvalidationQueue() {\r\n        _renderScheduled = undefined;\r\n        let invalidationQueue = [..._invalidationQueue];\r\n        const previouslyRendered = [];\r\n        _invalidationQueue = [];\r\n        invalidationQueue.sort((a, b) => {\r\n            let result = b.depth - a.depth;\r\n            if (result === 0) {\r\n                result = b.order - a.order;\r\n            }\r\n            return result;\r\n        });\r\n        if (_deferredProcessQueue.length) {\r\n            _processQueue = [..._deferredProcessQueue];\r\n            _deferredProcessQueue = [];\r\n            _runProcessQueue();\r\n            if (_deferredProcessQueue.length) {\r\n                _invalidationQueue = [...invalidationQueue];\r\n                invalidationQueue = [];\r\n            }\r\n        }\r\n        let item;\r\n        while ((item = invalidationQueue.pop())) {\r\n            let { id } = item;\r\n            const current = getWNodeWrapper(id);\r\n            if (!current || previouslyRendered.indexOf(id) !== -1 || !_idToWrapperMap.has(current.parentId)) {\r\n                continue;\r\n            }\r\n            previouslyRendered.push(id);\r\n            const sibling = _wrapperSiblingMap.get(current);\r\n            const next = {\r\n                node: {\r\n                    type: WNODE,\r\n                    widgetConstructor: current.node.widgetConstructor,\r\n                    properties: current.properties || {},\r\n                    children: current.node.children || []\r\n                },\r\n                instance: current.instance,\r\n                id: current.id,\r\n                properties: current.properties,\r\n                depth: current.depth,\r\n                order: current.order,\r\n                owningId: current.owningId,\r\n                parentId: current.parentId,\r\n                registryItem: current.registryItem\r\n            };\r\n            sibling && _wrapperSiblingMap.set(next, sibling);\r\n            const result = _updateWidget({ current, next });\r\n            if (result && result.item) {\r\n                _processQueue.push(result.item);\r\n                _idToWrapperMap.set(id, next);\r\n                _runProcessQueue();\r\n            }\r\n        }\r\n        _runDomInstructionQueue();\r\n        _cleanUpMergedNodes();\r\n        _scheduleDeferredRenderCallbacks();\r\n        if (!_renderScheduled) {\r\n            setRendering(false);\r\n        }\r\n    }\r\n    function _cleanUpMergedNodes() {\r\n        if (_deferredProcessQueue.length === 0) {\r\n            let mergedNode;\r\n            while ((mergedNode = _allMergedNodes.pop())) {\r\n                mergedNode.parentNode && mergedNode.parentNode.removeChild(mergedNode);\r\n            }\r\n            _mountOptions.merge = false;\r\n        }\r\n    }\r\n    function _runProcessQueue() {\r\n        let item;\r\n        while ((item = _processQueue.pop())) {\r\n            if (isAttachApplication(item)) {\r\n                item.instance && _applicationQueue.push(item);\r\n            }\r\n            else {\r\n                const { current, next, meta } = item;\r\n                _process(current || EMPTY_ARRAY, next || EMPTY_ARRAY, meta);\r\n            }\r\n        }\r\n    }\r\n    function _runDomInstructionQueue() {\r\n        _applicationQueue.reverse();\r\n        let item;\r\n        while ((item = _applicationQueue.pop())) {\r\n            if (item.type === 'create') {\r\n                const { parentDomNode, next, next: { domNode, merged, requiresInsertBefore, node } } = item;\r\n                processProperties(next, { properties: {} });\r\n                runDeferredProperties(next);\r\n                if (!merged) {\r\n                    let insertBefore;\r\n                    if (requiresInsertBefore) {\r\n                        insertBefore = findInsertBefore(next);\r\n                    }\r\n                    else if (_insertBeforeMap) {\r\n                        insertBefore = _insertBeforeMap.get(next);\r\n                    }\r\n                    parentDomNode.insertBefore(domNode, insertBefore);\r\n                    if (isDomVNode(next.node) && next.node.onAttach) {\r\n                        next.node.onAttach();\r\n                    }\r\n                }\r\n                if (domNode.tagName === 'OPTION' && domNode.parentElement) {\r\n                    setValue(domNode.parentElement);\r\n                }\r\n                const { enterAnimation, enterAnimationActive } = node.properties;\r\n                if (_mountOptions.transition && enterAnimation && enterAnimation !== true) {\r\n                    _mountOptions.transition.enter(domNode, enterAnimation, enterAnimationActive);\r\n                }\r\n                const owningWrapper = _nodeToWrapperMap.get(next.node);\r\n                if (owningWrapper && node.properties.key != null) {\r\n                    if (owningWrapper.instance) {\r\n                        const instanceData = widgetInstanceMap.get(owningWrapper.instance);\r\n                        instanceData && instanceData.nodeHandler.add(domNode, `${node.properties.key}`);\r\n                    }\r\n                    else {\r\n                        addNodeToMap(owningWrapper.id, node.properties.key, domNode);\r\n                    }\r\n                }\r\n                item.next.inserted = true;\r\n            }\r\n            else if (item.type === 'update') {\r\n                const { next, next: { domNode }, current, current: { domNode: currentDomNode } } = item;\r\n                if (isTextNode(domNode) && isTextNode(currentDomNode) && domNode !== currentDomNode) {\r\n                    currentDomNode.parentNode && currentDomNode.parentNode.replaceChild(domNode, currentDomNode);\r\n                }\r\n                else {\r\n                    const previousProperties = buildPreviousProperties(domNode, current);\r\n                    processProperties(next, previousProperties);\r\n                    runDeferredProperties(next);\r\n                }\r\n            }\r\n            else if (item.type === 'delete') {\r\n                const { current } = item;\r\n                const { exitAnimation, exitAnimationActive } = current.node.properties;\r\n                if (_mountOptions.transition && exitAnimation && exitAnimation !== true) {\r\n                    _mountOptions.transition.exit(current.domNode, exitAnimation, exitAnimationActive);\r\n                }\r\n                else {\r\n                    current.domNode.parentNode.removeChild(current.domNode);\r\n                }\r\n            }\r\n            else if (item.type === 'attach') {\r\n                const { instance, attached } = item;\r\n                const instanceData = widgetInstanceMap.get(instance);\r\n                if (instanceData) {\r\n                    instanceData.nodeHandler.addRoot();\r\n                    attached && instanceData.onAttach();\r\n                }\r\n            }\r\n            else if (item.type === 'detach') {\r\n                if (item.current.instance) {\r\n                    const instanceData = widgetInstanceMap.get(item.current.instance);\r\n                    instanceData && instanceData.onDetach();\r\n                }\r\n                item.current.instance = undefined;\r\n            }\r\n        }\r\n        if (_deferredProcessQueue.length === 0) {\r\n            _nodeToWrapperMap = new WeakMap();\r\n        }\r\n    }\r\n    function _processMergeNodes(next, mergeNodes) {\r\n        const { merge } = _mountOptions;\r\n        if (merge && mergeNodes.length) {\r\n            if (isVNodeWrapper(next)) {\r\n                let { node: { tag } } = next;\r\n                for (let i = 0; i < mergeNodes.length; i++) {\r\n                    const domElement = mergeNodes[i];\r\n                    const tagName = domElement.tagName || '';\r\n                    if (tag.toUpperCase() === tagName.toUpperCase()) {\r\n                        const mergeNodeIndex = _allMergedNodes.indexOf(domElement);\r\n                        if (mergeNodeIndex !== -1) {\r\n                            _allMergedNodes.splice(mergeNodeIndex, 1);\r\n                        }\r\n                        mergeNodes.splice(i, 1);\r\n                        next.domNode = domElement;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                next.mergeNodes = mergeNodes;\r\n            }\r\n        }\r\n    }\r\n    function distinguishableCheck(childNodes, index) {\r\n        const parentWNodeWrapper = getWNodeWrapper(childNodes[index].owningId);\r\n        checkDistinguishable(childNodes, index, parentWNodeWrapper);\r\n    }\r\n    function createKeyMap(wrappers) {\r\n        const keys = [];\r\n        for (let i = 0; i < wrappers.length; i++) {\r\n            const wrapper = wrappers[i];\r\n            if (wrapper.node.properties.key != null) {\r\n                keys.push(wrapper.node.properties.key);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        return keys;\r\n    }\r\n    function _process(current, next, meta = {}) {\r\n        let { mergeNodes = [], oldIndex = 0, newIndex = 0 } = meta;\r\n        const currentLength = current.length;\r\n        const nextLength = next.length;\r\n        const hasPreviousSiblings = currentLength > 1 || (currentLength > 0 && currentLength < nextLength);\r\n        let instructions = [];\r\n        let replace = false;\r\n        if (oldIndex === 0 && newIndex === 0 && currentLength) {\r\n            const currentKeys = createKeyMap(current);\r\n            if (currentKeys) {\r\n                const nextKeys = createKeyMap(next);\r\n                if (nextKeys) {\r\n                    for (let i = 0; i < currentKeys.length; i++) {\r\n                        if (nextKeys.indexOf(currentKeys[i]) !== -1) {\r\n                            instructions = [];\r\n                            replace = false;\r\n                            break;\r\n                        }\r\n                        replace = true;\r\n                        instructions.push({ current: current[i], next: undefined });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (replace || (currentLength === 0 && !_mountOptions.merge)) {\r\n            for (let i = 0; i < next.length; i++) {\r\n                instructions.push({ current: undefined, next: next[i] });\r\n            }\r\n        }\r\n        else {\r\n            if (newIndex < nextLength) {\r\n                let currentWrapper = oldIndex < currentLength ? current[oldIndex] : undefined;\r\n                const nextWrapper = next[newIndex];\r\n                nextWrapper.hasPreviousSiblings = hasPreviousSiblings;\r\n                _processMergeNodes(nextWrapper, mergeNodes);\r\n                if (currentWrapper && same(currentWrapper, nextWrapper)) {\r\n                    oldIndex++;\r\n                    newIndex++;\r\n                    if (isVNodeWrapper(currentWrapper) && isVNodeWrapper(nextWrapper)) {\r\n                        nextWrapper.inserted = currentWrapper.inserted;\r\n                    }\r\n                    instructions.push({ current: currentWrapper, next: nextWrapper });\r\n                }\r\n                else if (!currentWrapper || findIndexOfChild(current, nextWrapper, oldIndex + 1) === -1) {\r\n                    has('dojo-debug') && current.length && distinguishableCheck(next, newIndex);\r\n                    instructions.push({ current: undefined, next: nextWrapper });\r\n                    newIndex++;\r\n                }\r\n                else if (findIndexOfChild(next, currentWrapper, newIndex + 1) === -1) {\r\n                    has('dojo-debug') && distinguishableCheck(current, oldIndex);\r\n                    instructions.push({ current: currentWrapper, next: undefined });\r\n                    oldIndex++;\r\n                }\r\n                else {\r\n                    has('dojo-debug') && distinguishableCheck(next, newIndex);\r\n                    has('dojo-debug') && distinguishableCheck(current, oldIndex);\r\n                    instructions.push({ current: currentWrapper, next: undefined });\r\n                    instructions.push({ current: undefined, next: nextWrapper });\r\n                    oldIndex++;\r\n                    newIndex++;\r\n                }\r\n            }\r\n            if (newIndex < nextLength) {\r\n                _processQueue.push({ current, next, meta: { mergeNodes, oldIndex, newIndex } });\r\n            }\r\n            if (currentLength > oldIndex && newIndex >= nextLength) {\r\n                for (let i = oldIndex; i < currentLength; i++) {\r\n                    has('dojo-debug') && distinguishableCheck(current, i);\r\n                    instructions.push({ current: current[i], next: undefined });\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < instructions.length; i++) {\r\n            const result = _processOne(instructions[i]);\r\n            if (result === false) {\r\n                if (_mountOptions.merge && mergeNodes.length) {\r\n                    if (newIndex < nextLength) {\r\n                        _processQueue.pop();\r\n                    }\r\n                    _processQueue.push({ next, current, meta });\r\n                    _deferredProcessQueue = _processQueue;\r\n                    _processQueue = [];\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            const { widget, item, dom } = result;\r\n            widget && _processQueue.push(widget);\r\n            item && _processQueue.push(item);\r\n            dom && _applicationQueue.push(dom);\r\n        }\r\n    }\r\n    function _processOne({ current, next }) {\r\n        if (current !== next) {\r\n            if (!current && next) {\r\n                if (isVNodeWrapper(next)) {\r\n                    return _createDom({ next });\r\n                }\r\n                else {\r\n                    return _createWidget({ next });\r\n                }\r\n            }\r\n            else if (current && next) {\r\n                if (isVNodeWrapper(current) && isVNodeWrapper(next)) {\r\n                    return _updateDom({ current, next });\r\n                }\r\n                else if (isWNodeWrapper(current) && isWNodeWrapper(next)) {\r\n                    return _updateWidget({ current, next });\r\n                }\r\n            }\r\n            else if (current && !next) {\r\n                if (isVNodeWrapper(current)) {\r\n                    return _removeDom({ current });\r\n                }\r\n                else if (isWNodeWrapper(current)) {\r\n                    return _removeWidget({ current });\r\n                }\r\n            }\r\n        }\r\n        return {};\r\n    }\r\n    function createWidgetOptions(id, widgetId, middleware) {\r\n        return {\r\n            id,\r\n            properties: () => {\r\n                const widgetMeta = widgetMetaMap.get(widgetId);\r\n                if (widgetMeta) {\r\n                    widgetMeta.propertiesCalled = true;\r\n                    return Object.assign({}, widgetMeta.properties);\r\n                }\r\n                return {};\r\n            },\r\n            children: () => {\r\n                const widgetMeta = widgetMetaMap.get(widgetId);\r\n                if (widgetMeta) {\r\n                    return widgetMeta.children;\r\n                }\r\n                return [];\r\n            },\r\n            middleware\r\n        };\r\n    }\r\n    function resolveMiddleware(middlewares, id, middlewareIds = []) {\r\n        const keys = Object.keys(middlewares);\r\n        const results = {};\r\n        const uniqueId = `${id}-${metaId++}`;\r\n        for (let i = 0; i < keys.length; i++) {\r\n            const middleware = middlewares[keys[i]]();\r\n            const payload = createWidgetOptions(uniqueId, id);\r\n            if (middleware.middlewares) {\r\n                const { middlewares: resolvedMiddleware } = resolveMiddleware(middleware.middlewares, id, middlewareIds);\r\n                payload.middleware = resolvedMiddleware;\r\n                results[keys[i]] = middleware.callback(payload);\r\n            }\r\n            else {\r\n                results[keys[i]] = middleware.callback(payload);\r\n            }\r\n        }\r\n        middlewareIds.push(uniqueId);\r\n        return { middlewares: results, ids: middlewareIds };\r\n    }\r\n    function _createWidget({ next }) {\r\n        let { node: { widgetConstructor } } = next;\r\n        let { registry } = _mountOptions;\r\n        let Constructor = next.registryItem || widgetConstructor;\r\n        if (!isWidget(Constructor)) {\r\n            resolveRegistryItem(next);\r\n            if (!next.registryItem) {\r\n                return false;\r\n            }\r\n            Constructor = next.registryItem;\r\n        }\r\n        let rendered;\r\n        let invalidate;\r\n        next.properties = Object.assign({}, next.node.properties);\r\n        next.id = next.id || `${wrapperId++}`;\r\n        _idToWrapperMap.set(next.id, next);\r\n        const { id, depth, order } = next;\r\n        if (!isWidgetBaseConstructor(Constructor)) {\r\n            let widgetMeta = widgetMetaMap.get(id);\r\n            if (!widgetMeta) {\r\n                invalidate = () => {\r\n                    const widgetMeta = widgetMetaMap.get(id);\r\n                    if (widgetMeta) {\r\n                        widgetMeta.dirty = true;\r\n                        if (!widgetMeta.rendering && _idToWrapperMap.has(id)) {\r\n                            _invalidationQueue.push({ id, depth, order });\r\n                            _schedule();\r\n                        }\r\n                    }\r\n                };\r\n                widgetMeta = {\r\n                    widgetName: Constructor.name || 'unknown',\r\n                    mountNode: _mountOptions.domNode,\r\n                    dirty: false,\r\n                    invalidator: invalidate,\r\n                    properties: wrapFunctionProperties(id, next.node.properties),\r\n                    originalProperties: Object.assign({}, next.node.properties),\r\n                    children: next.node.children,\r\n                    deferRefs: 0,\r\n                    rendering: true,\r\n                    middleware: {},\r\n                    middlewareIds: [],\r\n                    registry: _mountOptions.registry,\r\n                    propertiesCalled: false\r\n                };\r\n                widgetMetaMap.set(next.id, widgetMeta);\r\n                if (Constructor.middlewares && Object.keys(Constructor.middlewares).length) {\r\n                    const { middlewares, ids } = resolveMiddleware(Constructor.middlewares, id);\r\n                    widgetMeta.middleware = middlewares;\r\n                    widgetMeta.middlewareIds = ids;\r\n                }\r\n            }\r\n            else {\r\n                invalidate = widgetMeta.invalidator;\r\n            }\r\n            rendered = Constructor(createWidgetOptions(id, id, widgetMeta.middleware));\r\n            widgetMeta.rendering = false;\r\n            widgetMeta.propertiesCalled = false;\r\n            if (widgetMeta.deferRefs > 0) {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            let instance = new Constructor();\r\n            instance.registry.base = registry;\r\n            const instanceData = widgetInstanceMap.get(instance);\r\n            invalidate = () => {\r\n                instanceData.dirty = true;\r\n                if (!instanceData.rendering && _idToWrapperMap.has(id)) {\r\n                    _invalidationQueue.push({ id, depth, order });\r\n                    _schedule();\r\n                }\r\n            };\r\n            instanceData.invalidate = invalidate;\r\n            instanceData.rendering = true;\r\n            instance.__setProperties__(next.node.properties);\r\n            instance.__setChildren__(next.node.children);\r\n            next.instance = instance;\r\n            rendered = instance.__render__();\r\n            instanceData.rendering = false;\r\n        }\r\n        let children;\r\n        if (rendered) {\r\n            rendered = Array.isArray(rendered) ? rendered : [rendered];\r\n            children = renderedToWrapper(rendered, next, null);\r\n            _idToChildrenWrappers.set(id, children);\r\n        }\r\n        if (!parentInvalidate && !Constructor.isWNodeWrapper) {\r\n            parentInvalidate = invalidate;\r\n        }\r\n        return {\r\n            item: {\r\n                next: children,\r\n                meta: { mergeNodes: next.mergeNodes }\r\n            },\r\n            widget: { type: 'attach', instance: next.instance, id, attached: true }\r\n        };\r\n    }\r\n    function _updateWidget({ current, next }) {\r\n        current = getWNodeWrapper(current.id) || current;\r\n        const { instance, domNode, hasAnimations, id } = current;\r\n        let { node: { widgetConstructor } } = next;\r\n        const Constructor = next.registryItem || widgetConstructor;\r\n        if (!isWidget(Constructor)) {\r\n            return {};\r\n        }\r\n        let rendered;\r\n        let processResult = {};\r\n        let didRender = false;\r\n        let currentChildren = _idToChildrenWrappers.get(current.id);\r\n        next.hasAnimations = hasAnimations;\r\n        next.id = id;\r\n        next.properties = Object.assign({}, next.node.properties);\r\n        _wrapperSiblingMap.delete(current);\r\n        if (domNode && domNode.parentNode) {\r\n            next.domNode = domNode;\r\n        }\r\n        if (!isWidgetBaseConstructor(Constructor)) {\r\n            const widgetMeta = widgetMetaMap.get(id);\r\n            if (widgetMeta) {\r\n                widgetMeta.originalProperties = Object.assign({}, next.properties);\r\n                widgetMeta.properties = wrapFunctionProperties(id, widgetMeta.originalProperties);\r\n                widgetMeta.children = next.node.children;\r\n                widgetMeta.rendering = true;\r\n                const customProperties = runDiffs(widgetMeta, current.properties, widgetMeta.originalProperties);\r\n                widgetMeta.properties = Object.assign({}, widgetMeta.properties, customProperties);\r\n                if (current.node.children.length > 0 || next.node.children.length > 0) {\r\n                    widgetMeta.dirty = true;\r\n                }\r\n                if (!widgetMeta.dirty) {\r\n                    propertiesDiff(current.properties, next.properties, () => {\r\n                        widgetMeta.dirty = true;\r\n                    }, widgetMeta.customDiffProperties ? [...widgetMeta.customDiffProperties.values()] : []);\r\n                }\r\n                if (widgetMeta.dirty) {\r\n                    _idToChildrenWrappers.delete(id);\r\n                    didRender = true;\r\n                    rendered = Constructor(createWidgetOptions(id, id, widgetMeta.middleware));\r\n                    widgetMeta.dirty = false;\r\n                    if (widgetMeta.deferRefs > 0) {\r\n                        rendered = null;\r\n                    }\r\n                }\r\n                widgetMeta.rendering = false;\r\n                widgetMeta.propertiesCalled = false;\r\n            }\r\n        }\r\n        else {\r\n            const instanceData = widgetInstanceMap.get(instance);\r\n            next.instance = instance;\r\n            instanceData.rendering = true;\r\n            instance.__setProperties__(next.node.properties);\r\n            instance.__setChildren__(next.node.children);\r\n            if (instanceData.dirty) {\r\n                didRender = true;\r\n                _idToChildrenWrappers.delete(id);\r\n                rendered = instance.__render__();\r\n            }\r\n            instanceData.rendering = false;\r\n        }\r\n        _idToWrapperMap.set(next.id, next);\r\n        processResult.widget = { type: 'attach', instance, id, attached: false };\r\n        let children;\r\n        if (rendered) {\r\n            rendered = Array.isArray(rendered) ? rendered : [rendered];\r\n            children = renderedToWrapper(rendered, next, current);\r\n            _idToChildrenWrappers.set(id, children);\r\n        }\r\n        if (didRender) {\r\n            processResult.item = {\r\n                current: currentChildren,\r\n                next: children,\r\n                meta: {}\r\n            };\r\n        }\r\n        return processResult;\r\n    }\r\n    function _removeWidget({ current }) {\r\n        current = getWNodeWrapper(current.id) || current;\r\n        _idToWrapperMap.delete(current.id);\r\n        const meta = widgetMetaMap.get(current.id);\r\n        let currentChildren = _idToChildrenWrappers.get(current.id);\r\n        _idToChildrenWrappers.delete(current.id);\r\n        _wrapperSiblingMap.delete(current);\r\n        let processResult = {\r\n            item: {\r\n                current: currentChildren,\r\n                meta: {}\r\n            }\r\n        };\r\n        if (meta) {\r\n            meta.registryHandler && meta.registryHandler.destroy();\r\n            destroyHandles(meta);\r\n            widgetMetaMap.delete(current.id);\r\n        }\r\n        else {\r\n            processResult.widget = { type: 'detach', current, instance: current.instance };\r\n        }\r\n        return processResult;\r\n    }\r\n    function findDomNodeOnParentWrapper(id) {\r\n        const children = _idToChildrenWrappers.get(id) || [];\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = children[i];\r\n            if (child.domNode) {\r\n                return child.id;\r\n            }\r\n            const childId = findDomNodeOnParentWrapper(child.id);\r\n            if (childId) {\r\n                return childId;\r\n            }\r\n        }\r\n    }\r\n    function _createDom({ next }) {\r\n        const parentDomNode = findParentDomNode(next);\r\n        const isVirtual = isVirtualWrapper(next);\r\n        const isBody = isBodyWrapper(next);\r\n        const isHead = isHeadWrapper(next);\r\n        let mergeNodes = [];\r\n        next.id = `${wrapperId++}`;\r\n        _idToWrapperMap.set(next.id, next);\r\n        if (!next.domNode) {\r\n            if (next.node.domNode) {\r\n                next.domNode = next.node.domNode;\r\n            }\r\n            else {\r\n                if (next.node.tag === 'svg') {\r\n                    next.namespace = NAMESPACE_SVG;\r\n                }\r\n                if (isBody) {\r\n                    next.domNode = global.document.body;\r\n                }\r\n                else if (isHead) {\r\n                    next.domNode = global.document.head;\r\n                }\r\n                else if (next.node.tag && !isVirtual) {\r\n                    if (next.namespace) {\r\n                        next.domNode = global.document.createElementNS(next.namespace, next.node.tag);\r\n                    }\r\n                    else {\r\n                        next.domNode = global.document.createElement(next.node.tag);\r\n                    }\r\n                }\r\n                else if (next.node.text != null) {\r\n                    next.domNode = global.document.createTextNode(next.node.text);\r\n                }\r\n            }\r\n            if (_insertBeforeMap && _allMergedNodes.length) {\r\n                if (parentDomNode === _allMergedNodes[0].parentNode) {\r\n                    _insertBeforeMap.set(next, _allMergedNodes[0]);\r\n                }\r\n            }\r\n        }\r\n        else if (_mountOptions.merge) {\r\n            next.merged = true;\r\n            if (isTextNode(next.domNode)) {\r\n                if (next.domNode.data !== next.node.text) {\r\n                    _allMergedNodes = [next.domNode, ..._allMergedNodes];\r\n                    next.domNode = global.document.createTextNode(next.node.text);\r\n                    next.merged = false;\r\n                }\r\n            }\r\n            else {\r\n                mergeNodes = arrayFrom(next.domNode.childNodes);\r\n                _allMergedNodes = [..._allMergedNodes, ...mergeNodes];\r\n            }\r\n        }\r\n        let children;\r\n        if (next.domNode || isVirtual) {\r\n            if (next.node.children && next.node.children.length) {\r\n                children = renderedToWrapper(next.node.children, next, null);\r\n                _idToChildrenWrappers.set(next.id, children);\r\n            }\r\n        }\r\n        const dom = isSpecialWrapper(next)\r\n            ? undefined\r\n            : {\r\n                next: next,\r\n                parentDomNode: parentDomNode,\r\n                type: 'create'\r\n            };\r\n        if (children) {\r\n            return {\r\n                item: {\r\n                    current: [],\r\n                    next: children,\r\n                    meta: { mergeNodes }\r\n                },\r\n                dom,\r\n                widget: isVirtual ? { type: 'attach', id: next.id, attached: false } : undefined\r\n            };\r\n        }\r\n        return { dom };\r\n    }\r\n    function _updateDom({ current, next }) {\r\n        next.domNode = current.domNode;\r\n        next.namespace = current.namespace;\r\n        next.id = current.id;\r\n        next.childDomWrapperId = current.childDomWrapperId;\r\n        let children;\r\n        let currentChildren = _idToChildrenWrappers.get(next.id);\r\n        if (next.node.text != null && next.node.text !== current.node.text) {\r\n            next.domNode = global.document.createTextNode(next.node.text);\r\n        }\r\n        else if (next.node.children) {\r\n            children = renderedToWrapper(next.node.children, next, current);\r\n            _idToChildrenWrappers.set(next.id, children);\r\n        }\r\n        _wrapperSiblingMap.delete(current);\r\n        _idToWrapperMap.set(next.id, next);\r\n        return {\r\n            item: {\r\n                current: currentChildren,\r\n                next: children,\r\n                meta: {}\r\n            },\r\n            dom: { type: 'update', next, current }\r\n        };\r\n    }\r\n    function _removeDom({ current }) {\r\n        const isSpecial = isSpecialWrapper(current);\r\n        const children = _idToChildrenWrappers.get(current.id);\r\n        _idToChildrenWrappers.delete(current.id);\r\n        _idToWrapperMap.delete(current.id);\r\n        _wrapperSiblingMap.delete(current);\r\n        if (current.node.properties.key) {\r\n            const widgetMeta = widgetMetaMap.get(current.owningId);\r\n            const parentWrapper = getWNodeWrapper(current.owningId);\r\n            if (widgetMeta) {\r\n                widgetMeta.nodeMap && widgetMeta.nodeMap.delete(current.node.properties.key);\r\n            }\r\n            else if (parentWrapper && parentWrapper.instance) {\r\n                const instanceData = widgetInstanceMap.get(parentWrapper.instance);\r\n                instanceData && instanceData.nodeHandler.remove(current.node.properties.key);\r\n            }\r\n        }\r\n        if (current.hasAnimations || isSpecial) {\r\n            return {\r\n                item: { current: children, meta: {} },\r\n                dom: isSpecial ? undefined : { type: 'delete', current }\r\n            };\r\n        }\r\n        if (children) {\r\n            _deferredRenderCallbacks.push(() => {\r\n                let wrappers = children || [];\r\n                let wrapper;\r\n                let specialIds = [];\r\n                while ((wrapper = wrappers.pop())) {\r\n                    if (isWNodeWrapper(wrapper)) {\r\n                        wrapper = getWNodeWrapper(wrapper.id) || wrapper;\r\n                        if (wrapper.instance) {\r\n                            const instanceData = widgetInstanceMap.get(wrapper.instance);\r\n                            instanceData && instanceData.onDetach();\r\n                            wrapper.instance = undefined;\r\n                        }\r\n                        else {\r\n                            const meta = widgetMetaMap.get(wrapper.id);\r\n                            if (meta) {\r\n                                meta.registryHandler && meta.registryHandler.destroy();\r\n                                destroyHandles(meta);\r\n                                widgetMetaMap.delete(wrapper.id);\r\n                            }\r\n                        }\r\n                    }\r\n                    let wrapperChildren = _idToChildrenWrappers.get(wrapper.id);\r\n                    if (wrapperChildren) {\r\n                        wrappers.push(...wrapperChildren);\r\n                    }\r\n                    if (isBodyWrapper(wrapper) || isHeadWrapper(wrapper)) {\r\n                        specialIds.push(wrapper.id);\r\n                    }\r\n                    else if (specialIds.indexOf(wrapper.parentId) !== -1) {\r\n                        if (isWNodeWrapper(wrapper) || isVirtualWrapper(wrapper)) {\r\n                            specialIds.push(wrapper.id);\r\n                        }\r\n                        else if (wrapper.domNode && wrapper.domNode.parentNode) {\r\n                            wrapper.domNode.parentNode.removeChild(wrapper.domNode);\r\n                        }\r\n                    }\r\n                    _idToChildrenWrappers.delete(wrapper.id);\r\n                    _idToWrapperMap.delete(wrapper.id);\r\n                }\r\n            });\r\n        }\r\n        return {\r\n            dom: { type: 'delete', current }\r\n        };\r\n    }\r\n    return {\r\n        mount,\r\n        unmount,\r\n        invalidate\r\n    };\r\n}\r\nexport default renderer;\r\n//# sourceMappingURL=vdom.mjs.map","import has from '../core/has';\r\nexport let assign;\r\n/**\r\n * Gets the own property descriptor of the specified object.\r\n * An own property descriptor is one that is defined directly on the object and is not\r\n * inherited from the object's prototype.\r\n * @param o Object that contains the property.\r\n * @param p Name of the property.\r\n */\r\nexport let getOwnPropertyDescriptor;\r\n/**\r\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\r\n * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\r\n * @param o Object that contains the own properties.\r\n */\r\nexport let getOwnPropertyNames;\r\n/**\r\n * Returns an array of all symbol properties found directly on object o.\r\n * @param o Object to retrieve the symbols from.\r\n */\r\nexport let getOwnPropertySymbols;\r\n/**\r\n * Returns true if the values are the same value, false otherwise.\r\n * @param value1 The first value.\r\n * @param value2 The second value.\r\n */\r\nexport let is;\r\n/**\r\n * Returns the names of the enumerable properties and methods of an object.\r\n * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\r\n */\r\nexport let keys;\r\n/* ES7 Object static methods */\r\nexport let getOwnPropertyDescriptors;\r\nexport let entries;\r\nexport let values;\r\nif (!true) {\r\n    const keys = Object.keys.bind(Object);\r\n    Object.keys = function symbolAwareKeys(o) {\r\n        return keys(o).filter((key) => !Boolean(key.match(/^@@.+/)));\r\n    };\r\n    Object.assign = function assign(target, ...sources) {\r\n        if (target == null) {\r\n            // TypeError if undefined or null\r\n            throw new TypeError('Cannot convert undefined or null to object');\r\n        }\r\n        const to = Object(target);\r\n        sources.forEach((nextSource) => {\r\n            if (nextSource) {\r\n                // Skip over if undefined or null\r\n                keys(nextSource).forEach((nextKey) => {\r\n                    to[nextKey] = nextSource[nextKey];\r\n                });\r\n            }\r\n        });\r\n        return to;\r\n    };\r\n    const getOwnPropertyNames = Object.getOwnPropertyNames.bind(Object);\r\n    Object.getOwnPropertyNames = function symbolAwareGetOwnPropertyNames(o) {\r\n        return getOwnPropertyNames(o).filter((key) => !Boolean(key.match(/^@@.+/)));\r\n    };\r\n    Object.getOwnPropertySymbols = function getOwnPropertySymbols(o) {\r\n        return getOwnPropertyNames(o)\r\n            .filter((key) => Boolean(key.match(/^@@.+/)))\r\n            .map((key) => Symbol.for(key.substring(2)));\r\n    };\r\n    Object.is = function is(value1, value2) {\r\n        if (value1 === value2) {\r\n            return value1 !== 0 || 1 / value1 === 1 / value2; // -0\r\n        }\r\n        return value1 !== value1 && value2 !== value2; // NaN\r\n    };\r\n}\r\nif (!true) {\r\n    Object.getOwnPropertyDescriptors = function getOwnPropertyDescriptors(o) {\r\n        return Object.getOwnPropertyNames(o).reduce((previous, key) => {\r\n            previous[key] = Object.getOwnPropertyDescriptor(o, key);\r\n            return previous;\r\n        }, {});\r\n    };\r\n    Object.entries = function entries(o) {\r\n        return keys(o).map((key) => [key, o[key]]);\r\n    };\r\n    Object.values = function values(o) {\r\n        return keys(o).map((key) => o[key]);\r\n    };\r\n}\r\nassign = Object.assign;\r\ngetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\r\ngetOwnPropertyNames = Object.getOwnPropertyNames;\r\ngetOwnPropertySymbols = Object.getOwnPropertySymbols;\r\nis = Object.is;\r\nkeys = Object.keys;\r\ngetOwnPropertyDescriptors = Object.getOwnPropertyDescriptors;\r\nentries = Object.entries;\r\nvalues = Object.values;\r\nexport default Object;\r\n//# sourceMappingURL=object.mjs.map","var _a;\r\nvar isArrayLike = undefined, ShimIterator = undefined;\r\n// !has('es6-iterator')\r\n// elided: import './iterator'\r\nimport global from './global';\r\nimport { is as objectIs } from './object';\r\nimport has from '../core/has';\r\n// !has('es6-symbol')\r\n// elided: import './Symbol'\r\nexport let Map = global.Map;\r\nif (!true) {\r\n    Map = global.Map = (_a = class Map {\r\n            constructor(iterable) {\r\n                this._keys = [];\r\n                this._values = [];\r\n                this[Symbol.toStringTag] = 'Map';\r\n                if (iterable) {\r\n                    if (isArrayLike(iterable)) {\r\n                        for (let i = 0; i < iterable.length; i++) {\r\n                            const value = iterable[i];\r\n                            this.set(value[0], value[1]);\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (const value of iterable) {\r\n                            this.set(value[0], value[1]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            /**\r\n             * An alternative to Array.prototype.indexOf using Object.is\r\n             * to check for equality. See http://mzl.la/1zuKO2V\r\n             */\r\n            _indexOfKey(keys, key) {\r\n                for (let i = 0, length = keys.length; i < length; i++) {\r\n                    if (objectIs(keys[i], key)) {\r\n                        return i;\r\n                    }\r\n                }\r\n                return -1;\r\n            }\r\n            get size() {\r\n                return this._keys.length;\r\n            }\r\n            clear() {\r\n                this._keys.length = this._values.length = 0;\r\n            }\r\n            delete(key) {\r\n                const index = this._indexOfKey(this._keys, key);\r\n                if (index < 0) {\r\n                    return false;\r\n                }\r\n                this._keys.splice(index, 1);\r\n                this._values.splice(index, 1);\r\n                return true;\r\n            }\r\n            entries() {\r\n                const values = this._keys.map((key, i) => {\r\n                    return [key, this._values[i]];\r\n                });\r\n                return new ShimIterator(values);\r\n            }\r\n            forEach(callback, context) {\r\n                const keys = this._keys;\r\n                const values = this._values;\r\n                for (let i = 0, length = keys.length; i < length; i++) {\r\n                    callback.call(context, values[i], keys[i], this);\r\n                }\r\n            }\r\n            get(key) {\r\n                const index = this._indexOfKey(this._keys, key);\r\n                return index < 0 ? undefined : this._values[index];\r\n            }\r\n            has(key) {\r\n                return this._indexOfKey(this._keys, key) > -1;\r\n            }\r\n            keys() {\r\n                return new ShimIterator(this._keys);\r\n            }\r\n            set(key, value) {\r\n                let index = this._indexOfKey(this._keys, key);\r\n                index = index < 0 ? this._keys.length : index;\r\n                this._keys[index] = key;\r\n                this._values[index] = value;\r\n                return this;\r\n            }\r\n            values() {\r\n                return new ShimIterator(this._values);\r\n            }\r\n            [Symbol.iterator]() {\r\n                return this.entries();\r\n            }\r\n        },\r\n        _a[Symbol.species] = _a,\r\n        _a);\r\n}\r\nexport default Map;","import global from '../shim/global';\r\n/**\r\n * A cache of results of feature tests\r\n */\r\nexport const testCache = {};\r\n/**\r\n * A cache of the un-resolved feature tests\r\n */\r\nexport const testFunctions = {};\r\n/* Grab the staticFeatures if there are available */\r\nconst { staticFeatures } = global.DojoHasEnvironment || {};\r\n/* Cleaning up the DojoHasEnviornment */\r\nif ('DojoHasEnvironment' in global) {\r\n    delete global.DojoHasEnvironment;\r\n}\r\n/**\r\n * Custom type guard to narrow the `staticFeatures` to either a map or a function that\r\n * returns a map.\r\n *\r\n * @param value The value to guard for\r\n */\r\nfunction isStaticFeatureFunction(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * The cache of asserted features that were available in the global scope when the\r\n * module loaded\r\n */\r\nconst staticCache = staticFeatures\r\n    ? isStaticFeatureFunction(staticFeatures)\r\n        ? staticFeatures.apply(global)\r\n        : staticFeatures\r\n    : {}; /* Providing an empty cache, if none was in the environment\r\n\r\n\r\n/**\r\n* AMD plugin function.\r\n*\r\n* Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\r\n* value(s).\r\n*\r\n* @param resourceId The id of the module\r\n* @param normalize Resolves a relative module id into an absolute module id\r\n*/\r\nexport function normalize(resourceId, normalize) {\r\n    const tokens = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\r\n    let i = 0;\r\n    function get(skip) {\r\n        const term = tokens[i++];\r\n        if (term === ':') {\r\n            // empty string module name, resolves to null\r\n            return null;\r\n        }\r\n        else {\r\n            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature\r\n            if (tokens[i++] === '?') {\r\n                if (!skip && has(term)) {\r\n                    // matched the feature, get the first value from the options\r\n                    return get();\r\n                }\r\n                else {\r\n                    // did not match, get the second value, passing over the first\r\n                    get(true);\r\n                    return get(skip);\r\n                }\r\n            }\r\n            // a module\r\n            return term;\r\n        }\r\n    }\r\n    const id = get();\r\n    return id && normalize(id);\r\n}\r\n/**\r\n * Check if a feature has already been registered\r\n *\r\n * @param feature the name of the feature\r\n */\r\nexport function exists(feature) {\r\n    const normalizedFeature = feature.toLowerCase();\r\n    return Boolean(normalizedFeature in staticCache || normalizedFeature in testCache || testFunctions[normalizedFeature]);\r\n}\r\n/**\r\n * Register a new test for a named feature.\r\n *\r\n * @example\r\n * has.add('dom-addeventlistener', !!document.addEventListener);\r\n *\r\n * @example\r\n * has.add('touch-events', function () {\r\n *    return 'ontouchstart' in document\r\n * });\r\n *\r\n * @param feature the name of the feature\r\n * @param value the value reported of the feature, or a function that will be executed once on first test\r\n * @param overwrite if an existing value should be overwritten. Defaults to false.\r\n */\r\nexport function add(feature, value, overwrite = false) {\r\n    const normalizedFeature = feature.toLowerCase();\r\n    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {\r\n        throw new TypeError(`Feature \"${feature}\" exists and overwrite not true.`);\r\n    }\r\n    if (typeof value === 'function') {\r\n        testFunctions[normalizedFeature] = value;\r\n    }\r\n    else {\r\n        testCache[normalizedFeature] = value;\r\n        delete testFunctions[normalizedFeature];\r\n    }\r\n}\r\n/**\r\n * Return the current value of a named feature.\r\n *\r\n * @param feature The name of the feature to test.\r\n */\r\nexport default function has(feature, strict = false) {\r\n    let result;\r\n    const normalizedFeature = feature.toLowerCase();\r\n    if (normalizedFeature in staticCache) {\r\n        result = staticCache[normalizedFeature];\r\n    }\r\n    else if (testFunctions[normalizedFeature]) {\r\n        result = testCache[normalizedFeature] = testFunctions[normalizedFeature].call(null);\r\n        delete testFunctions[normalizedFeature];\r\n    }\r\n    else if (normalizedFeature in testCache) {\r\n        result = testCache[normalizedFeature];\r\n    }\r\n    else if (strict) {\r\n        throw new TypeError(`Attempt to detect unregistered has feature \"${feature}\"`);\r\n    }\r\n    return result;\r\n}\r\n/*\r\n * Out of the box feature tests\r\n */\r\nadd('public-path', undefined);\r\n/* flag for dojo debug, default to false */\r\nadd('dojo-debug', false);\r\n/* Detects if the environment is \"browser like\" */\r\nadd('host-browser', true);\r\n/* Detects if the environment is \"jsdom\" */\r\nadd('host-jsdom', true && typeof navigator !== 'undefined' && navigator.userAgent.indexOf('jsdom') !== -1);\r\n/* Detects if the environment appears to be NodeJS */\r\nadd('host-node', false);\r\nadd('fetch', true);\r\nadd('es6-array', true);\r\nadd('es6-array-fill', true);\r\nadd('es7-array', true);\r\nadd('es2019-array', true);\r\n/* Map */\r\nadd('es6-map', true);\r\nadd('es6-iterator', true);\r\n/* Math */\r\nadd('es6-math', true);\r\nadd('es6-math-imul', true);\r\n/* Object */\r\nadd('es6-object', true);\r\nadd('es2017-object', true);\r\n/* Observable */\r\nadd('es-observable', false);\r\n/* Promise */\r\nadd('es6-promise', true);\r\nadd('es2018-promise-finally', () => true && typeof global.Promise.prototype.finally !== 'undefined', true);\r\n/* Set */\r\nadd('es6-set', true);\r\n/* String */\r\nadd('es6-string', true);\r\nadd('es6-string-raw', true);\r\nadd('es2017-string', true);\r\n/* Symbol */\r\nadd('es6-symbol', true);\r\n/* WeakMap */\r\nadd('es6-weakmap', true);\r\n/* Miscellaneous features */\r\nadd('microtasks', true);\r\nadd('postmessage', true);\r\nadd('raf', true);\r\nadd('setimmediate', false);\r\n/* DOM Features */\r\nadd('dom-mutationobserver', true);\r\nadd('dom-webanimation', () => true && global.Animation !== undefined && global.KeyframeEffect !== undefined, true);\r\nadd('abort-controller', () => typeof global.AbortController !== 'undefined');\r\nadd('abort-signal', () => typeof global.AbortSignal !== 'undefined');\r\nadd('dom-intersection-observer', () => true && global.IntersectionObserver !== undefined, true);\r\nadd('dom-resize-observer', () => true && global.ResizeObserver !== undefined, true);\r\nadd('dom-pointer-events', () => true && global.onpointerdown !== undefined, true);\r\nadd('dom-css-variables', true);\r\nadd('dom-inert', () => true && Element.prototype.hasOwnProperty('inert'), true);\r\nadd('build-elide', false);\r\nadd('test', false);\r\nadd('global-this', () => typeof global.globalThis !== 'undefined');\r\n//# sourceMappingURL=has.mjs.map","import Promise from '../shim/Promise';\r\nimport Map from '../shim/Map';\r\nimport { Evented } from '../core/Evented';\r\n/**\r\n * Widget base type\r\n */\r\nexport const WIDGET_BASE_TYPE = '__widget_base_type';\r\n/**\r\n * Checks is the item is a subclass of WidgetBase (or a WidgetBase)\r\n *\r\n * @param item the item to check\r\n * @returns true/false indicating if the item is a WidgetBaseConstructor\r\n */\r\nexport function isWidgetBaseConstructor(item) {\r\n    return Boolean(item && item._type === WIDGET_BASE_TYPE);\r\n}\r\nexport function isWidgetFunction(item) {\r\n    return Boolean(item && item.isWidget);\r\n}\r\nexport function isWNodeFactory(node) {\r\n    if (typeof node === 'function' && node.isFactory) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport function isWidget(item) {\r\n    return isWidgetBaseConstructor(item) || isWidgetFunction(item);\r\n}\r\nexport function isWidgetConstructorDefaultExport(item) {\r\n    return Boolean(item &&\r\n        item.hasOwnProperty('__esModule') &&\r\n        item.hasOwnProperty('default') &&\r\n        (isWidget(item.default) || isWNodeFactory(item.default)));\r\n}\r\n/**\r\n * The Registry implementation\r\n */\r\nexport class Registry extends Evented {\r\n    /**\r\n     * Emit loaded event for registry label\r\n     */\r\n    emitLoadedEvent(widgetLabel, item) {\r\n        this.emit({\r\n            type: widgetLabel,\r\n            action: 'loaded',\r\n            item\r\n        });\r\n    }\r\n    define(label, item) {\r\n        if (this._widgetRegistry === undefined) {\r\n            this._widgetRegistry = new Map();\r\n        }\r\n        if (this._widgetRegistry.has(label)) {\r\n            throw new Error(`widget has already been registered for '${label.toString()}'`);\r\n        }\r\n        this._widgetRegistry.set(label, item);\r\n        if (item instanceof Promise) {\r\n            item.then((widgetCtor) => {\r\n                this._widgetRegistry.set(label, widgetCtor);\r\n                this.emitLoadedEvent(label, widgetCtor);\r\n                return widgetCtor;\r\n            }, (error) => {\r\n                throw error;\r\n            });\r\n        }\r\n        else if (isWidgetBaseConstructor(item)) {\r\n            this.emitLoadedEvent(label, item);\r\n        }\r\n    }\r\n    defineInjector(label, injectorFactory) {\r\n        if (this._injectorRegistry === undefined) {\r\n            this._injectorRegistry = new Map();\r\n        }\r\n        if (this._injectorRegistry.has(label)) {\r\n            throw new Error(`injector has already been registered for '${label.toString()}'`);\r\n        }\r\n        const invalidator = new Evented();\r\n        const injectorItem = {\r\n            injector: injectorFactory(() => invalidator.emit({ type: 'invalidate' })),\r\n            invalidator\r\n        };\r\n        this._injectorRegistry.set(label, injectorItem);\r\n        this.emitLoadedEvent(label, injectorItem);\r\n    }\r\n    get(label) {\r\n        if (!this._widgetRegistry || !this.has(label)) {\r\n            return null;\r\n        }\r\n        const item = this._widgetRegistry.get(label);\r\n        if (isWidget(item) || isWNodeFactory(item)) {\r\n            return item;\r\n        }\r\n        if (item instanceof Promise) {\r\n            return null;\r\n        }\r\n        const promise = item();\r\n        this._widgetRegistry.set(label, promise);\r\n        promise.then((widgetCtor) => {\r\n            if (isWidgetConstructorDefaultExport(widgetCtor)) {\r\n                widgetCtor = widgetCtor.default;\r\n            }\r\n            this._widgetRegistry.set(label, widgetCtor);\r\n            this.emitLoadedEvent(label, widgetCtor);\r\n            return widgetCtor;\r\n        }, (error) => {\r\n            throw error;\r\n        });\r\n        return null;\r\n    }\r\n    getInjector(label) {\r\n        if (!this._injectorRegistry || !this.hasInjector(label)) {\r\n            return null;\r\n        }\r\n        return this._injectorRegistry.get(label);\r\n    }\r\n    has(label) {\r\n        return Boolean(this._widgetRegistry && this._widgetRegistry.has(label));\r\n    }\r\n    hasInjector(label) {\r\n        return Boolean(this._injectorRegistry && this._injectorRegistry.has(label));\r\n    }\r\n}\r\nexport default Registry;\r\n//# sourceMappingURL=Registry.mjs.map","import { Evented } from '../core/Evented';\nexport class Injector extends Evented {\n    constructor(payload) {\n        super();\n        this._payload = payload;\n    }\n    setInvalidator(invalidator) {\n        this._invalidator = invalidator;\n    }\n    get() {\n        return this._payload;\n    }\n    set(payload) {\n        this._payload = payload;\n        if (this._invalidator) {\n            this._invalidator();\n        }\n    }\n}\nexport default Injector;\n//# sourceMappingURL=Injector.mjs.map","import global from '../shim/global';\r\nimport Injector from './Injector';\r\nimport cssVars from '../shim/cssVariables';\r\nimport Map from '../shim/Map';\r\nimport has from './has';\r\nexport function isVariantModule(variant) {\r\n    return typeof variant !== 'string';\r\n}\r\nexport function isThemeWithVariant(theme) {\r\n    return theme && theme.hasOwnProperty('variant');\r\n}\r\nexport function isThemeWithVariants(theme) {\r\n    return theme && theme.hasOwnProperty('variants');\r\n}\r\nexport function isThemeInjectorPayloadWithVariant(theme) {\r\n    return !!theme && theme.hasOwnProperty('variant');\r\n}\r\nlet processCssVariant = function (_) { };\r\nif (!true) {\r\n    const setUpCssVariantSupport = () => {\r\n        const styleId = '__dojo_processed_styles';\r\n        const processedCssMap = new Map();\r\n        let variantStyleElement;\r\n        function applyStyles(css) {\r\n            const style = document.createElement('style');\r\n            style.textContent = css;\r\n            style.setAttribute('id', styleId);\r\n            if (variantStyleElement && variantStyleElement.parentNode) {\r\n                variantStyleElement.parentNode.replaceChild(style, variantStyleElement);\r\n            }\r\n            else {\r\n                global.document.head.appendChild(style);\r\n            }\r\n            variantStyleElement = style;\r\n        }\r\n        return function processCssVariant(variantName) {\r\n            const processedCss = processedCssMap.get(variantName);\r\n            if (processedCss) {\r\n                applyStyles(processedCss);\r\n            }\r\n            else {\r\n                cssVars({\r\n                    exclude: `style[id=${styleId}]`,\r\n                    onSuccess: (css) => {\r\n                        let temp = css;\r\n                        let index = temp.indexOf(variantName);\r\n                        let variantCss = '';\r\n                        while (index !== -1) {\r\n                            temp = temp.substring(index + variantName.length);\r\n                            const match = temp.match(/\\{([^}]+)\\}/);\r\n                            if (match) {\r\n                                if (variantCss) {\r\n                                    variantCss = `${variantCss.substring(0, variantCss.length - 1)}${match[0].substring(1)}`;\r\n                                }\r\n                                else {\r\n                                    variantCss = match[0];\r\n                                }\r\n                            }\r\n                            index = temp.indexOf(variantName);\r\n                        }\r\n                        if (variantCss) {\r\n                            css = `:root ${variantCss}${css}`;\r\n                        }\r\n                        return css;\r\n                    },\r\n                    onComplete: (css) => {\r\n                        processedCssMap.set(variantName, css);\r\n                        applyStyles(css);\r\n                    },\r\n                    updateDOM: false,\r\n                    silent: true\r\n                });\r\n            }\r\n        };\r\n    };\r\n    processCssVariant = setUpCssVariantSupport();\r\n}\r\nfunction createThemeInjectorPayload(theme, variant) {\r\n    if (isThemeWithVariant(theme)) {\r\n        if (typeof theme.variant === 'string') {\r\n            return {\r\n                theme: theme.theme,\r\n                variant: { name: theme.variant, value: theme.theme.variants[theme.variant] }\r\n            };\r\n        }\r\n        return { theme: theme.theme, variant: theme.variant };\r\n    }\r\n    else if (isThemeWithVariants(theme)) {\r\n        variant = variant || 'default';\r\n        if (isVariantModule(variant)) {\r\n            if (!true) {\r\n                processCssVariant(variant.value.root);\r\n            }\r\n            return { theme, variant };\r\n        }\r\n        if (!true) {\r\n            processCssVariant(theme.variants[variant].root);\r\n        }\r\n        return { theme: theme, variant: { name: variant, value: theme.variants[variant] } };\r\n    }\r\n    return { theme };\r\n}\r\nexport class ThemeInjector extends Injector {\r\n    constructor(theme) {\r\n        super(theme ? createThemeInjectorPayload(theme) : theme);\r\n    }\r\n    set(theme, variant) {\r\n        super.set(createThemeInjectorPayload(theme, variant));\r\n    }\r\n    get() {\r\n        return super.get();\r\n    }\r\n}\r\nexport default ThemeInjector;\r\n//# sourceMappingURL=ThemeInjector.mjs.map","import Promise from '../shim/Promise';\n/**\n * No op function used to replace a Destroyable instance's `destroy` method, once the instance has been destroyed\n */\nfunction noop() {\n    return Promise.resolve(false);\n}\n/**\n * No op function used to replace a Destroyable instance's `own` method, once the instance has been destroyed\n */\nfunction destroyed() {\n    throw new Error('Call made to destroyed method');\n}\nexport class Destroyable {\n    /**\n     * @constructor\n     */\n    constructor() {\n        this.handles = [];\n    }\n    /**\n     * Register handles for the instance that will be destroyed when `this.destroy` is called\n     *\n     * @param {Handle} handle The handle to add for the instance\n     * @returns {Handle} A wrapper Handle. When the wrapper Handle's `destroy` method is invoked, the original handle is\n     *                   removed from the instance, and its `destroy` method is invoked.\n     */\n    own(handle) {\n        const { handles: _handles } = this;\n        _handles.push(handle);\n        return {\n            destroy() {\n                _handles.splice(_handles.indexOf(handle));\n                handle.destroy();\n            }\n        };\n    }\n    /**\n     * Destroys all handlers registered for the instance\n     *\n     * @returns {Promise<any} A Promise that resolves once all handles have been destroyed\n     */\n    destroy() {\n        return new Promise((resolve) => {\n            this.handles.forEach((handle) => {\n                handle && handle.destroy && handle.destroy();\n            });\n            this.destroy = noop;\n            this.own = destroyed;\n            resolve(true);\n        });\n    }\n}\nexport default Destroyable;\n//# sourceMappingURL=Destroyable.mjs.map","import Map from '../shim/Map';\r\nimport { Destroyable } from './Destroyable';\r\n/**\r\n * Map of computed regular expressions, keyed by string\r\n */\r\nconst regexMap = new Map();\r\n/**\r\n * Determines if the event type glob has been matched\r\n *\r\n * @returns boolean that indicates if the glob is matched\r\n */\r\nexport function isGlobMatch(globString, targetString) {\r\n    if (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {\r\n        let regex;\r\n        if (regexMap.has(globString)) {\r\n            regex = regexMap.get(globString);\r\n        }\r\n        else {\r\n            regex = new RegExp(`^${globString.replace(/\\*/g, '.*')}$`);\r\n            regexMap.set(globString, regex);\r\n        }\r\n        return regex.test(targetString);\r\n    }\r\n    else {\r\n        return globString === targetString;\r\n    }\r\n}\r\n/**\r\n * Event Class\r\n */\r\nexport class Evented extends Destroyable {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * map of listeners keyed by event type\r\n         */\r\n        this.listenersMap = new Map();\r\n    }\r\n    emit(event) {\r\n        this.listenersMap.forEach((methods, type) => {\r\n            if (isGlobMatch(type, event.type)) {\r\n                [...methods].forEach((method) => {\r\n                    method.call(this, event);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    on(type, listener) {\r\n        if (Array.isArray(listener)) {\r\n            const handles = listener.map((listener) => this._addListener(type, listener));\r\n            return {\r\n                destroy() {\r\n                    handles.forEach((handle) => handle.destroy());\r\n                }\r\n            };\r\n        }\r\n        return this._addListener(type, listener);\r\n    }\r\n    _addListener(type, listener) {\r\n        const listeners = this.listenersMap.get(type) || [];\r\n        listeners.push(listener);\r\n        this.listenersMap.set(type, listeners);\r\n        return {\r\n            destroy: () => {\r\n                const listeners = this.listenersMap.get(type) || [];\r\n                listeners.splice(listeners.indexOf(listener), 1);\r\n            }\r\n        };\r\n    }\r\n}\r\nexport default Evented;\r\n//# sourceMappingURL=Evented.mjs.map","var _a;\r\nimport global from './global';\r\nvar queueMicroTask = undefined;\r\n// !has('microtasks')\r\n// elided: import './support/queue'\r\n// !has('es6-symbol')\r\n// elided: import './Symbol'\r\nimport has from '../core/has';\r\nexport let ShimPromise = global.Promise;\r\nexport const isThenable = function isThenable(value) {\r\n    return value && typeof value.then === 'function';\r\n};\r\nif (!true) {\r\n    global.Promise = ShimPromise = (_a = class Promise {\r\n            /**\r\n             * Creates a new Promise.\r\n             *\r\n             * @constructor\r\n             *\r\n             * @param executor\r\n             * The executor function is called immediately when the Promise is instantiated. It is responsible for\r\n             * starting the asynchronous operation when it is invoked.\r\n             *\r\n             * The executor must call either the passed `resolve` function when the asynchronous operation has completed\r\n             * successfully, or the `reject` function when the operation fails.\r\n             */\r\n            constructor(executor) {\r\n                /**\r\n                 * The current state of this promise.\r\n                 */\r\n                this.state = 1 /* Pending */;\r\n                this[Symbol.toStringTag] = 'Promise';\r\n                /**\r\n                 * If true, the resolution of this promise is chained (\"locked in\") to another promise.\r\n                 */\r\n                let isChained = false;\r\n                /**\r\n                 * Whether or not this promise is in a resolved state.\r\n                 */\r\n                const isResolved = () => {\r\n                    return this.state !== 1 /* Pending */ || isChained;\r\n                };\r\n                /**\r\n                 * Callbacks that should be invoked once the asynchronous operation has completed.\r\n                 */\r\n                let callbacks = [];\r\n                /**\r\n                 * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\r\n                 * enqueues callbacks for execution on the next event loop turn.\r\n                 */\r\n                let whenFinished = function (callback) {\r\n                    if (callbacks) {\r\n                        callbacks.push(callback);\r\n                    }\r\n                };\r\n                /**\r\n                 * Settles this promise.\r\n                 *\r\n                 * @param newState The resolved state for this promise.\r\n                 * @param {T|any} value The resolved value for this promise.\r\n                 */\r\n                const settle = (newState, value) => {\r\n                    // A promise can only be settled once.\r\n                    if (this.state !== 1 /* Pending */) {\r\n                        return;\r\n                    }\r\n                    this.state = newState;\r\n                    this.resolvedValue = value;\r\n                    whenFinished = queueMicroTask;\r\n                    // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\r\n                    // wait an extra turn.\r\n                    if (callbacks && callbacks.length > 0) {\r\n                        queueMicroTask(function () {\r\n                            if (callbacks) {\r\n                                let count = callbacks.length;\r\n                                for (let i = 0; i < count; ++i) {\r\n                                    callbacks[i].call(null);\r\n                                }\r\n                                callbacks = null;\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n                /**\r\n                 * Resolves this promise.\r\n                 *\r\n                 * @param newState The resolved state for this promise.\r\n                 * @param {T|any} value The resolved value for this promise.\r\n                 */\r\n                const resolve = (newState, value) => {\r\n                    if (isResolved()) {\r\n                        return;\r\n                    }\r\n                    if (isThenable(value)) {\r\n                        value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));\r\n                        isChained = true;\r\n                    }\r\n                    else {\r\n                        settle(newState, value);\r\n                    }\r\n                };\r\n                this.then = (onFulfilled, onRejected) => {\r\n                    return new Promise((resolve, reject) => {\r\n                        // whenFinished initially queues up callbacks for execution after the promise has settled. Once the\r\n                        // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\r\n                        // event loop.\r\n                        whenFinished(() => {\r\n                            const callback = this.state === 2 /* Rejected */ ? onRejected : onFulfilled;\r\n                            if (typeof callback === 'function') {\r\n                                try {\r\n                                    resolve(callback(this.resolvedValue));\r\n                                }\r\n                                catch (error) {\r\n                                    reject(error);\r\n                                }\r\n                            }\r\n                            else if (this.state === 2 /* Rejected */) {\r\n                                reject(this.resolvedValue);\r\n                            }\r\n                            else {\r\n                                resolve(this.resolvedValue);\r\n                            }\r\n                        });\r\n                    });\r\n                };\r\n                try {\r\n                    executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));\r\n                }\r\n                catch (error) {\r\n                    settle(2 /* Rejected */, error);\r\n                }\r\n            }\r\n            static all(iterable) {\r\n                return new this(function (resolve, reject) {\r\n                    const values = [];\r\n                    let complete = 0;\r\n                    let total = 0;\r\n                    let populating = true;\r\n                    function fulfill(index, value) {\r\n                        values[index] = value;\r\n                        ++complete;\r\n                        finish();\r\n                    }\r\n                    function finish() {\r\n                        if (populating || complete < total) {\r\n                            return;\r\n                        }\r\n                        resolve(values);\r\n                    }\r\n                    function processItem(index, item) {\r\n                        ++total;\r\n                        if (isThenable(item)) {\r\n                            // If an item Promise rejects, this Promise is immediately rejected with the item\r\n                            // Promise's rejection error.\r\n                            item.then(fulfill.bind(null, index), reject);\r\n                        }\r\n                        else {\r\n                            Promise.resolve(item).then(fulfill.bind(null, index));\r\n                        }\r\n                    }\r\n                    let i = 0;\r\n                    for (const value of iterable) {\r\n                        processItem(i, value);\r\n                        i++;\r\n                    }\r\n                    populating = false;\r\n                    finish();\r\n                });\r\n            }\r\n            static race(iterable) {\r\n                return new this(function (resolve, reject) {\r\n                    for (const item of iterable) {\r\n                        if (item instanceof Promise) {\r\n                            // If a Promise item rejects, this Promise is immediately rejected with the item\r\n                            // Promise's rejection error.\r\n                            item.then(resolve, reject);\r\n                        }\r\n                        else {\r\n                            Promise.resolve(item).then(resolve);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            static reject(reason) {\r\n                return new this(function (resolve, reject) {\r\n                    reject(reason);\r\n                });\r\n            }\r\n            static resolve(value) {\r\n                return new this(function (resolve) {\r\n                    resolve(value);\r\n                });\r\n            }\r\n            catch(onRejected) {\r\n                return this.then(undefined, onRejected);\r\n            }\r\n        },\r\n        _a[Symbol.species] = ShimPromise,\r\n        _a);\r\n    // this cast is needed in order to omit finally in the class declaration; this was done so the finally code\r\n    // is not duplicated and always added in the conditional below\r\n}\r\nif (!has('es2018-promise-finally')) {\r\n    global.Promise.prototype.finally = function (onFinally) {\r\n        return this.then(onFinally && ((value) => Promise.resolve(onFinally()).then(() => value)), onFinally &&\r\n            ((reason) => Promise.resolve(onFinally()).then(() => {\r\n                throw reason;\r\n            })));\r\n    };\r\n}\r\nexport default ShimPromise;","var _a;\r\nimport global from './global';\r\nvar isArrayLike = undefined, ShimIterator = undefined;\r\n// !has('es6-iterator')\r\n// elided: import './iterator'\r\nimport has from '../core/has';\r\n// !has('es6-symbol')\r\n// elided: import './Symbol'\r\nexport let Set = global.Set;\r\nif (!true) {\r\n    Set = global.Set = (_a = class Set {\r\n            constructor(iterable) {\r\n                this._setData = [];\r\n                this[Symbol.toStringTag] = 'Set';\r\n                if (iterable) {\r\n                    if (isArrayLike(iterable)) {\r\n                        for (let i = 0; i < iterable.length; i++) {\r\n                            this.add(iterable[i]);\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (const value of iterable) {\r\n                            this.add(value);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            add(value) {\r\n                if (this.has(value)) {\r\n                    return this;\r\n                }\r\n                this._setData.push(value);\r\n                return this;\r\n            }\r\n            clear() {\r\n                this._setData.length = 0;\r\n            }\r\n            delete(value) {\r\n                const idx = this._setData.indexOf(value);\r\n                if (idx === -1) {\r\n                    return false;\r\n                }\r\n                this._setData.splice(idx, 1);\r\n                return true;\r\n            }\r\n            entries() {\r\n                return new ShimIterator(this._setData.map((value) => [value, value]));\r\n            }\r\n            forEach(callbackfn, thisArg) {\r\n                const iterator = this.values();\r\n                let result = iterator.next();\r\n                while (!result.done) {\r\n                    callbackfn.call(thisArg, result.value, result.value, this);\r\n                    result = iterator.next();\r\n                }\r\n            }\r\n            has(value) {\r\n                return this._setData.indexOf(value) > -1;\r\n            }\r\n            keys() {\r\n                return new ShimIterator(this._setData);\r\n            }\r\n            get size() {\r\n                return this._setData.length;\r\n            }\r\n            values() {\r\n                return new ShimIterator(this._setData);\r\n            }\r\n            [Symbol.iterator]() {\r\n                return new ShimIterator(this._setData);\r\n            }\r\n        },\r\n        _a[Symbol.species] = _a,\r\n        _a);\r\n}\r\nexport default Set;","import { WIDGET_BASE_TYPE } from './Registry';\nfunction isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Array.isArray(value);\n}\nexport function always(previousProperty, newProperty) {\n    return {\n        changed: true,\n        value: newProperty\n    };\n}\nexport function ignore(previousProperty, newProperty) {\n    return {\n        changed: false,\n        value: newProperty\n    };\n}\nexport function reference(previousProperty, newProperty) {\n    return {\n        changed: previousProperty !== newProperty,\n        value: newProperty\n    };\n}\nexport function shallow(previousProperty, newProperty, depth = 0) {\n    let changed = false;\n    const validOldProperty = previousProperty && isObjectOrArray(previousProperty);\n    const validNewProperty = newProperty && isObjectOrArray(newProperty);\n    if (!validOldProperty || !validNewProperty) {\n        return {\n            changed: true,\n            value: newProperty\n        };\n    }\n    const previousKeys = Object.keys(previousProperty);\n    const newKeys = Object.keys(newProperty);\n    if (previousKeys.length !== newKeys.length) {\n        changed = true;\n    }\n    else {\n        changed = newKeys.some((key) => {\n            if (depth > 0) {\n                return auto(newProperty[key], previousProperty[key], depth - 1).changed;\n            }\n            return newProperty[key] !== previousProperty[key];\n        });\n    }\n    return {\n        changed,\n        value: newProperty\n    };\n}\nexport function auto(previousProperty, newProperty, depth = 0) {\n    let result;\n    if (typeof newProperty === 'function') {\n        if (newProperty._type === WIDGET_BASE_TYPE) {\n            result = reference(previousProperty, newProperty);\n        }\n        else {\n            result = ignore(previousProperty, newProperty);\n        }\n    }\n    else if (isObjectOrArray(newProperty)) {\n        result = shallow(previousProperty, newProperty, depth);\n    }\n    else {\n        result = reference(previousProperty, newProperty);\n    }\n    return result;\n}\n//# sourceMappingURL=diff.mjs.map","/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nexport function getValueDescriptor(value, enumerable = false, writable = true, configurable = true) {\n    return {\n        value: value,\n        enumerable: enumerable,\n        writable: writable,\n        configurable: configurable\n    };\n}\nexport function wrapNative(nativeFunction) {\n    return function (target, ...args) {\n        return nativeFunction.apply(target, args);\n    };\n}\n//# sourceMappingURL=util.mjs.map","var isArrayLike = undefined, isIterable = undefined;\r\n// !has('es6-iterator')\r\n// elided: import './iterator'\r\nimport has from '../core/has';\r\nimport { wrapNative } from './support/util';\r\nexport let from;\r\nexport let of;\r\nexport let copyWithin;\r\nexport let fill;\r\nexport let find;\r\nexport let findIndex;\r\nexport let includes;\r\nexport let flat;\r\nexport let flatMap;\r\nlet toLength;\r\nlet toInteger;\r\nlet normalizeOffset;\r\nif (!true || !true || !true) {\r\n    const MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\r\n    /**\r\n     * Ensures a non-negative, non-infinite, safe integer.\r\n     *\r\n     * @param length The number to validate\r\n     * @return A proper length\r\n     */\r\n    toLength = function toLength(length) {\r\n        if (isNaN(length)) {\r\n            return 0;\r\n        }\r\n        length = Number(length);\r\n        if (isFinite(length)) {\r\n            length = Math.floor(length);\r\n        }\r\n        // Ensure a non-negative, real, safe integer\r\n        return Math.min(Math.max(length, 0), MAX_SAFE_INTEGER);\r\n    };\r\n    /**\r\n     * From ES6 7.1.4 ToInteger()\r\n     *\r\n     * @param value A value to convert\r\n     * @return An integer\r\n     */\r\n    toInteger = function toInteger(value) {\r\n        value = Number(value);\r\n        if (isNaN(value)) {\r\n            return 0;\r\n        }\r\n        if (value === 0 || !isFinite(value)) {\r\n            return value;\r\n        }\r\n        return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\r\n    };\r\n    /**\r\n     * Normalizes an offset against a given length, wrapping it if negative.\r\n     *\r\n     * @param value The original offset\r\n     * @param length The total length to normalize against\r\n     * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\r\n     */\r\n    normalizeOffset = function normalizeOffset(value, length) {\r\n        return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\r\n    };\r\n}\r\nif (!true) {\r\n    Array.from = function from(arrayLike, mapFunction, thisArg) {\r\n        if (arrayLike == null) {\r\n            throw new TypeError('from: requires an array-like object');\r\n        }\r\n        if (mapFunction && thisArg) {\r\n            mapFunction = mapFunction.bind(thisArg);\r\n        }\r\n        /* tslint:disable-next-line:variable-name */\r\n        const Constructor = this;\r\n        const length = toLength(arrayLike.length);\r\n        // Support extension\r\n        const array = typeof Constructor === 'function' ? Object(new Constructor(length)) : new Array(length);\r\n        if (!isArrayLike(arrayLike) && !isIterable(arrayLike)) {\r\n            return array;\r\n        }\r\n        // if this is an array and the normalized length is 0, just return an empty array. this prevents a problem\r\n        // with the iteration on IE when using a NaN array length.\r\n        if (isArrayLike(arrayLike)) {\r\n            if (length === 0) {\r\n                return [];\r\n            }\r\n            for (let i = 0; i < arrayLike.length; i++) {\r\n                array[i] = mapFunction ? mapFunction(arrayLike[i], i) : arrayLike[i];\r\n            }\r\n        }\r\n        else {\r\n            let i = 0;\r\n            for (const value of arrayLike) {\r\n                array[i] = mapFunction ? mapFunction(value, i) : value;\r\n                i++;\r\n            }\r\n        }\r\n        if (arrayLike.length !== undefined) {\r\n            array.length = length;\r\n        }\r\n        return array;\r\n    };\r\n    Array.of = function of(...items) {\r\n        return Array.prototype.slice.call(items);\r\n    };\r\n    Array.prototype.copyWithin = function copyWithin(offset, start, end) {\r\n        if (this == null) {\r\n            throw new TypeError('copyWithin: target must be an array-like object');\r\n        }\r\n        const length = toLength(this.length);\r\n        offset = normalizeOffset(toInteger(offset), length);\r\n        start = normalizeOffset(toInteger(start), length);\r\n        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\r\n        let count = Math.min(end - start, length - offset);\r\n        let direction = 1;\r\n        if (offset > start && offset < start + count) {\r\n            direction = -1;\r\n            start += count - 1;\r\n            offset += count - 1;\r\n        }\r\n        while (count > 0) {\r\n            if (start in this) {\r\n                this[offset] = this[start];\r\n            }\r\n            else {\r\n                delete this[offset];\r\n            }\r\n            offset += direction;\r\n            start += direction;\r\n            count--;\r\n        }\r\n        return this;\r\n    };\r\n    Array.prototype.find = function find(callback, thisArg) {\r\n        const index = this.findIndex(callback, thisArg);\r\n        return index !== -1 ? this[index] : undefined;\r\n    };\r\n    Array.prototype.findIndex = function findIndex(callback, thisArg) {\r\n        const length = toLength(this.length);\r\n        if (!callback) {\r\n            throw new TypeError('find: second argument must be a function');\r\n        }\r\n        if (thisArg) {\r\n            callback = callback.bind(thisArg);\r\n        }\r\n        for (let i = 0; i < length; i++) {\r\n            if (callback(this[i], i, this)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n}\r\nif (!true) {\r\n    Array.prototype.fill = function fill(value, start, end) {\r\n        const length = toLength(this.length);\r\n        let i = normalizeOffset(toInteger(start), length);\r\n        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\r\n        while (i < (end || 0)) {\r\n            this[i++] = value;\r\n        }\r\n        return this;\r\n    };\r\n}\r\nif (!true) {\r\n    Array.prototype.includes = function includes(searchElement, fromIndex = 0) {\r\n        let len = toLength(this.length);\r\n        for (let i = fromIndex; i < len; ++i) {\r\n            const currentElement = this[i];\r\n            if (searchElement === currentElement ||\r\n                (searchElement !== searchElement && currentElement !== currentElement)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n}\r\nif (!true) {\r\n    Array.prototype.flat = function flat(depth = 1) {\r\n        return depth > 0\r\n            ? this.reduce((acc, val) => acc.concat(Array.isArray(val) ? val.flat(depth - 1) : val), [])\r\n            : this.slice();\r\n    };\r\n    Array.prototype.flatMap = function flatMap(callback) {\r\n        return this.map(callback).flat();\r\n    };\r\n}\r\nfrom = Array.from;\r\nof = Array.of;\r\ncopyWithin = wrapNative(Array.prototype.copyWithin);\r\nfill = wrapNative(Array.prototype.fill);\r\nfind = wrapNative(Array.prototype.find);\r\nflat = wrapNative(Array.prototype.flat);\r\nflatMap = wrapNative(Array.prototype.flatMap);\r\nfindIndex = wrapNative(Array.prototype.findIndex);\r\nincludes = wrapNative(Array.prototype.includes);\r\nexport default Array;","require('C:/git/libraries-modern-dojo-dai-widgets/node_modules/@dojo/widgets/theme/default/button.m.css');\nmodule.exports = {\" _key\":\"@dojo/widgets/button\",\"root\":\"button-m__root__wCywK\",\"pressed\":\"button-m__pressed__2zyjz\",\"popup\":\"button-m__popup__2Fl0t\",\"disabled\":\"button-m__disabled__19w7M\",\"label\":\"button-m__label__3hxN8\"};;","/*** IMPORTS FROM imports-loader ***/\nvar widgetFactory = require(\"src/button-wrapper/ButtonWrapper\");\n\nvar registerCustomElement = require('@dojo/framework/core/registerCustomElement').default;\n\nvar defaultExport = widgetFactory.default;\ndefaultExport && registerCustomElement(defaultExport);\n\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import Registry from './Registry';\nimport { create as vdomCreate, diffProperty, dom as vdomDom, invalidator, isTextNode, renderer, w as vdomW } from './vdom';\nimport { from } from '../shim/array';\nimport global from '../shim/global';\nimport ThemeInjector from './ThemeInjector';\nconst RESERVED_PROPS = ['focus'];\nexport var CustomElementChildType;\n(function (CustomElementChildType) {\n    CustomElementChildType[\"DOJO\"] = \"DOJO\";\n    CustomElementChildType[\"NODE\"] = \"NODE\";\n    CustomElementChildType[\"TEXT\"] = \"TEXT\";\n})(CustomElementChildType || (CustomElementChildType = {}));\nfunction isElement(item) {\n    return item && item.nodeType === 1;\n}\nfunction isDojoChild(item) {\n    return isElement(item) && item.tagName.indexOf('-') > -1;\n}\nfunction w(node, properties, children) {\n    const wrappedWNode = vdomW(node, properties, children);\n    function wrapper(...args) {\n        const { domNode } = node;\n        if (args.length && domNode) {\n            setTimeout(() => {\n                domNode.dispatchEvent(new CustomEvent('render', {\n                    bubbles: false,\n                    detail: args\n                }));\n            });\n        }\n        return wrappedWNode;\n    }\n    Object.keys(wrappedWNode).forEach((key) => (wrapper[key] = wrappedWNode[key]));\n    return wrapper;\n}\nfunction dom(options, children) {\n    const wrappedDomNode = vdomDom(options, children);\n    function wrapper(...args) {\n        const { domNode } = wrappedDomNode;\n        if (args.length && domNode) {\n            setTimeout(() => {\n                domNode.dispatchEvent(new CustomEvent('render', {\n                    bubbles: false,\n                    detail: args\n                }));\n            });\n        }\n        return wrappedDomNode;\n    }\n    Object.keys(wrappedDomNode).forEach((key) => (wrapper[key] = wrappedDomNode[key]));\n    return wrapper;\n}\nconst factory = vdomCreate({ diffProperty, invalidator }).properties();\nexport function DomToWidgetWrapper(domNode) {\n    const wrapper = factory(function DomToWidgetWrapper({ properties, middleware: { invalidator, diffProperty } }) {\n        diffProperty('', invalidator);\n        const props = Object.keys(properties()).reduce((props, key) => {\n            const value = properties()[key];\n            if (key.indexOf('on') === 0 || RESERVED_PROPS.indexOf(key) !== -1) {\n                key = `__${key}`;\n            }\n            props[key] = value;\n            return props;\n        }, {});\n        return dom({ node: domNode, props, diffType: 'dom' });\n    });\n    wrapper.domNode = domNode;\n    return wrapper;\n}\nfunction registerThemeInjector(theme, themeRegistry) {\n    const themeInjector = new ThemeInjector(theme);\n    themeRegistry.defineInjector('__theme_injector', (invalidator) => {\n        themeInjector.setInvalidator(invalidator);\n        return () => themeInjector;\n    });\n    return themeInjector;\n}\nexport function create(descriptor, WidgetConstructor) {\n    const { attributes = [], properties = [], registryFactory = () => new Registry() } = descriptor;\n    const attributeMap = {};\n    attributes.forEach((propertyName) => {\n        const attributeName = propertyName.toLowerCase();\n        attributeMap[attributeName] = propertyName;\n    });\n    properties.forEach((propertyName) => {\n        const attributeName = propertyName.toLowerCase();\n        attributeMap[attributeName] = propertyName;\n    });\n    return class extends HTMLElement {\n        constructor() {\n            super(...arguments);\n            this._properties = {};\n            this._children = [];\n            this._eventProperties = {};\n            this._propertiesMap = {};\n            this._initialised = false;\n            this._childType = descriptor.childType;\n        }\n        connectedCallback() {\n            if (this._initialised) {\n                return;\n            }\n            this._waitTillReady();\n        }\n        _hasBeenParsed() {\n            if (document.readyState !== 'loading') {\n                return true;\n            }\n            let element = this;\n            while (element) {\n                if (element.nextSibling) {\n                    return true;\n                }\n                element = element.parentNode;\n            }\n            return false;\n        }\n        _waitTillReady() {\n            this._initialised = true;\n            if (this._hasBeenParsed()) {\n                this._readyCallback();\n            }\n            else {\n                setTimeout(() => {\n                    this._waitTillReady();\n                }, 100);\n            }\n        }\n        _readyCallback() {\n            const domProperties = {};\n            const { properties = [], events = [] } = descriptor;\n            this._properties = Object.assign({}, this._propertiesWithAttributes(properties), this._attributesToProperties(attributes));\n            [...attributes, ...properties].forEach((propertyName) => {\n                const isReservedProp = RESERVED_PROPS.indexOf(propertyName) !== -1;\n                const value = this._propertiesMap[propertyName] || !isReservedProp ? this[propertyName] : undefined;\n                let filteredPropertyName = propertyName.replace(/^on/, '__');\n                if (isReservedProp) {\n                    filteredPropertyName = `__${propertyName}`;\n                }\n                if (value !== undefined) {\n                    this._properties[propertyName] = value;\n                }\n                if (filteredPropertyName !== propertyName) {\n                    domProperties[filteredPropertyName] = {\n                        get: () => this._getProperty(propertyName),\n                        set: (value) => this._setProperty(propertyName, value)\n                    };\n                }\n                if (!isReservedProp) {\n                    domProperties[propertyName] = {\n                        get: () => this._getProperty(propertyName),\n                        set: (value) => this._setProperty(propertyName, value)\n                    };\n                }\n            });\n            events.forEach((propertyName) => {\n                const eventName = propertyName.replace(/^on/, '').toLowerCase();\n                const filteredPropertyName = propertyName.replace(/^on/, '__on');\n                domProperties[filteredPropertyName] = {\n                    get: () => this._getEventProperty(propertyName),\n                    set: (value) => this._setEventProperty(propertyName, value)\n                };\n                this._eventProperties[propertyName] = undefined;\n                this._properties[propertyName] = (...args) => {\n                    const eventCallback = this._getEventProperty(propertyName);\n                    if (typeof eventCallback === 'function') {\n                        eventCallback(...args);\n                    }\n                    this.dispatchEvent(new CustomEvent(eventName, {\n                        bubbles: false,\n                        detail: args\n                    }));\n                };\n            });\n            Object.defineProperties(this, domProperties);\n            const children = from(this.childNodes).filter((childNode) => !isTextNode(childNode) || childNode.data.replace(/^\\s+|\\s+$/g, ''));\n            if (!this._childType) {\n                if (children.some((child) => isDojoChild(child))) {\n                    this._childType = CustomElementChildType.DOJO;\n                }\n                else {\n                    this._childType = CustomElementChildType.NODE;\n                }\n            }\n            from(children).forEach((childNode) => {\n                if (this._childType === CustomElementChildType.DOJO) {\n                    childNode.addEventListener('dojo-ce-render', () => this._render());\n                    childNode.addEventListener('dojo-ce-connected', () => this._render());\n                    this._children.push(DomToWidgetWrapper(childNode));\n                }\n                else {\n                    this._children.push(dom({ node: childNode, diffType: 'dom' }));\n                }\n            });\n            this.addEventListener('dojo-ce-connected', (e) => this._childConnected(e));\n            const widgetProperties = this._properties;\n            const renderChildren = () => this.__children__();\n            const Wrapper = factory(() => w(WidgetConstructor, widgetProperties, renderChildren()));\n            const registry = registryFactory();\n            const themeContext = registerThemeInjector(this._getVariant() ? { theme: this._getTheme(), variant: this._getVariant() } : this._getTheme(), registry);\n            global.addEventListener('dojo-theme-set', () => {\n                const variant = this._getVariant();\n                if (variant !== 'noVariant') {\n                    themeContext.set(this._getTheme(), variant);\n                }\n                else {\n                    themeContext.set(this._getTheme());\n                }\n            });\n            const r = renderer(() => w(Wrapper, {}));\n            this._renderer = r;\n            r.mount({ domNode: this, merge: false, registry });\n            const root = this.children[0];\n            if (root) {\n                const { display = 'block' } = global.getComputedStyle(root);\n                this.style.display = display;\n            }\n            this.dispatchEvent(new CustomEvent('dojo-ce-connected', {\n                bubbles: true,\n                detail: this\n            }));\n        }\n        _getTheme() {\n            if (global && global.dojoce && global.dojoce.theme) {\n                return global.dojoce.themes[global.dojoce.theme];\n            }\n        }\n        _getVariant() {\n            if (global && global.dojoce && global.dojoce.variant) {\n                return global.dojoce.variant;\n            }\n        }\n        _childConnected(e) {\n            const node = e.detail;\n            if (node.parentNode === this) {\n                const exists = this._children.some((child) => child.domNode === node);\n                if (!exists) {\n                    node.addEventListener('dojo-ce-render', () => this._render());\n                    this._children.push(DomToWidgetWrapper(node));\n                    this._render();\n                }\n            }\n        }\n        _render() {\n            if (this._renderer) {\n                this._renderer.invalidate();\n                this.dispatchEvent(new CustomEvent('dojo-ce-render', {\n                    bubbles: false,\n                    detail: this\n                }));\n            }\n        }\n        __properties__() {\n            return Object.assign({}, this._properties, this._eventProperties);\n        }\n        __children__() {\n            if (this._children.some((child) => child.domNode.getAttribute && child.domNode.getAttribute('slot'))) {\n                const slots = this._children.reduce((slots, child) => {\n                    const { domNode } = child;\n                    const slotName = domNode.getAttribute && domNode.getAttribute('slot');\n                    if (!slotName) {\n                        return slots;\n                    }\n                    let slotResult = child.isFactory\n                        ? w(child, domNode.__properties__ ? Object.assign({}, domNode.__properties__()) : {}, domNode.__children__ ? [...domNode.__children__()] : [])\n                        : child;\n                    const existingSlotValue = slots[slotName];\n                    return Object.assign({}, slots, { [slotName]: existingSlotValue ? [...existingSlotValue, slotResult] : [slotResult] });\n                }, {});\n                return [\n                    Object.keys(slots).reduce((result, key) => {\n                        const value = slots[key];\n                        return Object.assign({}, result, { [key]: value.length === 1 ? value[0] : value });\n                    }, {})\n                ];\n            }\n            if (this._childType === CustomElementChildType.DOJO) {\n                return this._children.filter((Child) => Child.domNode.isWidget).map((Child) => {\n                    const { domNode } = Child;\n                    return w(Child, Object.assign({}, domNode.__properties__()), [...domNode.__children__()]);\n                });\n            }\n            else {\n                return this._children;\n            }\n        }\n        attributeChangedCallback(name, oldValue, value) {\n            const propertyName = attributeMap[name];\n            if (attributes.indexOf(propertyName) >= 0) {\n                this._setProperty(propertyName, value);\n            }\n            else {\n                try {\n                    const parsedValue = value ? JSON.parse(value) : null;\n                    this._setProperty(propertyName, parsedValue);\n                }\n                catch (e) {\n                    // if json parsing error, we do not set the property\n                }\n            }\n        }\n        _setEventProperty(propertyName, value) {\n            this._eventProperties[propertyName] = value;\n        }\n        _getEventProperty(propertyName) {\n            return this._eventProperties[propertyName];\n        }\n        _setProperty(propertyName, value) {\n            this._properties[propertyName] = value;\n            this._render();\n        }\n        _getProperty(propertyName) {\n            return this._properties[propertyName];\n        }\n        _propertiesWithAttributes(properties) {\n            return properties.reduce((properties, propertyName) => {\n                const attributeName = propertyName.toLowerCase();\n                const value = this.getAttribute(attributeName);\n                if (value !== null) {\n                    try {\n                        properties[propertyName] = JSON.parse(value);\n                    }\n                    catch (e) {\n                        // invalid json values do not get set\n                    }\n                }\n                return properties;\n            }, {});\n        }\n        _attributesToProperties(attributes) {\n            return attributes.reduce((properties, propertyName) => {\n                const attributeName = propertyName.toLowerCase();\n                const value = this.getAttribute(attributeName);\n                if (value !== null) {\n                    properties[propertyName] = value;\n                }\n                return properties;\n            }, {});\n        }\n        static get observedAttributes() {\n            return Object.keys(attributeMap);\n        }\n        get isWidget() {\n            return true;\n        }\n        set(key, value) {\n            this._propertiesMap[key] = value;\n            if (this._renderer) {\n                this._setProperty(key, value);\n            }\n        }\n    };\n}\nexport function register(WidgetConstructor) {\n    const descriptor = WidgetConstructor.__customElementDescriptor;\n    if (!descriptor) {\n        throw new Error('Cannot get descriptor for Custom Element, have you added the @customElement decorator to your Widget?');\n    }\n    global.customElements.define(descriptor.tagName, create(descriptor, WidgetConstructor));\n}\nexport default register;\n//# sourceMappingURL=registerCustomElement.mjs.map","/* tslint:disable:interface-name */\r\nimport Map from '../../shim/Map';\r\nimport { create, invalidator, destroy } from '../vdom';\r\nconst factory = create({ invalidator, destroy });\r\nconst icacheFactory = factory(({ middleware: { invalidator, destroy } }) => {\r\n    const cacheMap = new Map();\r\n    destroy(() => {\r\n        cacheMap.clear();\r\n    });\r\n    const api = {\r\n        get: (key) => {\r\n            const cachedValue = cacheMap.get(key);\r\n            if (!cachedValue || cachedValue.status === 'pending') {\r\n                return undefined;\r\n            }\r\n            return cachedValue.value;\r\n        }\r\n    };\r\n    api.set = (key, value, invalidate = true) => {\r\n        const current = api.get(key);\r\n        if (typeof value === 'function') {\r\n            value = value(current);\r\n            if (value && typeof value.then === 'function') {\r\n                cacheMap.set(key, {\r\n                    status: 'pending',\r\n                    value\r\n                });\r\n                value.then((result) => {\r\n                    const cachedValue = cacheMap.get(key);\r\n                    if (cachedValue && cachedValue.value === value) {\r\n                        cacheMap.set(key, {\r\n                            status: 'resolved',\r\n                            value: result\r\n                        });\r\n                        invalidate && invalidator();\r\n                    }\r\n                });\r\n                return undefined;\r\n            }\r\n        }\r\n        cacheMap.set(key, {\r\n            status: 'resolved',\r\n            value\r\n        });\r\n        invalidate && invalidator();\r\n        return value;\r\n    };\r\n    api.has = (key) => {\r\n        return cacheMap.has(key);\r\n    };\r\n    api.delete = (key, invalidate = true) => {\r\n        cacheMap.delete(key);\r\n        invalidate && invalidator();\r\n    };\r\n    api.clear = (invalidate = true) => {\r\n        cacheMap.clear();\r\n        invalidate && invalidator();\r\n    };\r\n    api.getOrSet = (key, value, invalidate = true) => {\r\n        let cachedValue = cacheMap.get(key);\r\n        if (!cachedValue) {\r\n            api.set(key, value, invalidate);\r\n        }\r\n        cachedValue = cacheMap.get(key);\r\n        if (!cachedValue || cachedValue.status === 'pending') {\r\n            return undefined;\r\n        }\r\n        return cachedValue.value;\r\n    };\r\n    return api;\r\n});\r\nexport const createICacheMiddleware = () => icacheFactory.withType();\r\nexport const icache = createICacheMiddleware();\r\nexport default icache;\r\n//# sourceMappingURL=icache.mjs.map","import global from '../../shim/global';\r\nimport { create, diffProperty, node, destroy, invalidator } from '../vdom';\r\nimport { createICacheMiddleware } from './icache';\r\nconst icache = createICacheMiddleware();\r\nconst factory = create({ icache, diffProperty, node, destroy, invalidator }).properties();\r\nexport const focus = factory(({ middleware: { icache, diffProperty, node, destroy, invalidator } }) => {\r\n    let initialized = false;\r\n    let currentElement;\r\n    let previous = 0;\r\n    const nodeSet = new Set();\r\n    diffProperty('focus', (_, next) => {\r\n        const result = next.focus && next.focus();\r\n        if (result) {\r\n            const current = icache.getOrSet('current', 0);\r\n            icache.set('current', current + 1);\r\n        }\r\n    });\r\n    function onFocusChange() {\r\n        const activeElement = global.document.activeElement;\r\n        if ((nodeSet.has(currentElement) || nodeSet.has(activeElement)) && currentElement !== activeElement) {\r\n            invalidator();\r\n        }\r\n        currentElement = activeElement;\r\n    }\r\n    destroy(() => {\r\n        global.document.removeEventListener('focusin', onFocusChange);\r\n        global.document.removeEventListener('focusout', onFocusChange);\r\n        nodeSet.clear();\r\n    });\r\n    return {\r\n        shouldFocus() {\r\n            const current = icache.get('current') || 0;\r\n            const shouldFocus = current !== previous;\r\n            previous = current;\r\n            return shouldFocus;\r\n        },\r\n        focus() {\r\n            const current = icache.getOrSet('current', 0);\r\n            icache.set('current', current + 1);\r\n        },\r\n        isFocused(key) {\r\n            const domNode = node.get(key);\r\n            if (!domNode) {\r\n                return false;\r\n            }\r\n            nodeSet.add(domNode);\r\n            if (!initialized) {\r\n                global.document.addEventListener('focusin', onFocusChange);\r\n                global.document.addEventListener('focusout', onFocusChange);\r\n                initialized = true;\r\n            }\r\n            return global.document.activeElement === domNode;\r\n        }\r\n    };\r\n});\r\nexport default focus;\r\n//# sourceMappingURL=focus.mjs.map","import { isVNode, isWNode } from '@dojo/framework/core/vdom';\nexport var Keys;\n(function (Keys) {\n    Keys[Keys[\"Down\"] = 40] = \"Down\";\n    Keys[Keys[\"End\"] = 35] = \"End\";\n    Keys[Keys[\"Enter\"] = 13] = \"Enter\";\n    Keys[Keys[\"Escape\"] = 27] = \"Escape\";\n    Keys[Keys[\"Home\"] = 36] = \"Home\";\n    Keys[Keys[\"Left\"] = 37] = \"Left\";\n    Keys[Keys[\"PageDown\"] = 34] = \"PageDown\";\n    Keys[Keys[\"PageUp\"] = 33] = \"PageUp\";\n    Keys[Keys[\"Right\"] = 39] = \"Right\";\n    Keys[Keys[\"Space\"] = 32] = \"Space\";\n    Keys[Keys[\"Tab\"] = 9] = \"Tab\";\n    Keys[Keys[\"Up\"] = 38] = \"Up\";\n})(Keys || (Keys = {}));\nexport function formatAriaProperties(aria) {\n    const formattedAria = Object.keys(aria).reduce((a, key) => {\n        a[`aria-${key.toLowerCase()}`] = aria[key];\n        return a;\n    }, {});\n    return formattedAria;\n}\nexport function isRenderResult(child) {\n    let childIsRenderResult = child == null ||\n        typeof child === 'string' ||\n        typeof child === 'boolean' ||\n        Array.isArray(child) ||\n        isWNode(child);\n    try {\n        childIsRenderResult = childIsRenderResult || isVNode(child);\n    }\n    catch (_a) { }\n    return childIsRenderResult;\n}\n\n/*# sourceMappingURL=util.mjs.map*/","import { create, getRegistry, invalidator, destroy } from '../vdom';\nconst injectorFactory = create({ getRegistry, invalidator, destroy });\nexport const injector = injectorFactory(({ middleware: { getRegistry, invalidator, destroy } }) => {\n    const handles = [];\n    destroy(() => {\n        let handle;\n        while ((handle = handles.pop())) {\n            handle.destroy();\n        }\n    });\n    const registry = getRegistry();\n    return {\n        subscribe(label, callback = invalidator) {\n            if (registry) {\n                const item = registry.getInjector(label);\n                if (item) {\n                    const handle = item.invalidator.on('invalidate', () => {\n                        callback();\n                    });\n                    handles.push(handle);\n                    return () => {\n                        const index = handles.indexOf(handle);\n                        if (index !== -1) {\n                            handles.splice(index, 1);\n                            handle.destroy();\n                        }\n                    };\n                }\n            }\n        },\n        get(label) {\n            if (registry) {\n                const item = registry.getInjector(label);\n                if (item) {\n                    return item.injector();\n                }\n            }\n            return null;\n        }\n    };\n});\nexport default injector;\n//# sourceMappingURL=injector.mjs.map","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nimport { create, invalidator, diffProperty, getRegistry } from '../vdom';\nimport icache from './icache';\nimport injector from './injector';\nimport Set from '../../shim/Set';\nimport { auto } from '../diff';\nimport { ThemeInjector, isThemeInjectorPayloadWithVariant, isThemeWithVariants, isThemeWithVariant } from '../ThemeInjector';\nexport const THEME_KEY = ' _key';\nexport const INJECTED_THEME_KEY = '__theme_injector';\nfunction registerThemeInjector(theme, themeRegistry) {\n    const themeInjector = new ThemeInjector(theme);\n    themeRegistry.defineInjector(INJECTED_THEME_KEY, (invalidator) => {\n        themeInjector.setInvalidator(invalidator);\n        return () => themeInjector;\n    });\n    return themeInjector;\n}\nconst factory = create({ invalidator, icache, diffProperty, injector, getRegistry }).properties();\nexport const theme = factory(({ middleware: { invalidator, icache, diffProperty, injector, getRegistry }, properties }) => {\n    let themeKeys = new Set();\n    diffProperty('theme', properties, (current, next) => {\n        const { changed } = auto(current.theme, next.theme, 3);\n        if (changed) {\n            icache.clear();\n            invalidator();\n        }\n    });\n    diffProperty('classes', (current, next) => {\n        let result = false;\n        if ((current.classes && !next.classes) || (!current.classes && next.classes)) {\n            result = true;\n        }\n        else if (current.classes && next.classes) {\n            const keys = [...themeKeys.values()];\n            for (let i = 0; i < keys.length; i++) {\n                let key = keys[i];\n                result = auto(current.classes[key], next.classes[key], 2).changed;\n                if (result) {\n                    break;\n                }\n            }\n        }\n        if (result) {\n            icache.clear();\n            invalidator();\n        }\n    });\n    function getTheme() {\n        const { theme } = properties();\n        if (theme) {\n            return theme;\n        }\n        const themeInjector = injector.get(INJECTED_THEME_KEY);\n        if (themeInjector) {\n            const themePayload = themeInjector.get();\n            if (isThemeInjectorPayloadWithVariant(themePayload)) {\n                return { theme: themePayload.theme, variant: themePayload.variant };\n            }\n            else if (themePayload) {\n                return themePayload.theme;\n            }\n        }\n    }\n    const themeInjector = injector.get(INJECTED_THEME_KEY);\n    if (!themeInjector) {\n        const registry = getRegistry();\n        if (registry) {\n            registerThemeInjector(undefined, registry.base);\n        }\n    }\n    injector.subscribe(INJECTED_THEME_KEY, () => {\n        icache.clear();\n        invalidator();\n    });\n    function set(theme, variant) {\n        const currentTheme = injector.get(INJECTED_THEME_KEY);\n        if (currentTheme) {\n            if (isThemeWithVariants(theme)) {\n                currentTheme.set(theme, variant);\n            }\n            else {\n                currentTheme.set(theme);\n            }\n        }\n    }\n    return {\n        classes(css) {\n            const cachedTheme = icache.get(css);\n            if (cachedTheme) {\n                return cachedTheme;\n            }\n            const _a = THEME_KEY, key = css[_a], classes = __rest(css, [typeof _a === \"symbol\" ? _a : _a + \"\"]);\n            themeKeys.add(key);\n            let theme = classes;\n            let { classes: currentClasses } = properties();\n            let currentTheme = getTheme();\n            if (currentTheme && isThemeWithVariant(currentTheme)) {\n                currentTheme = isThemeWithVariants(currentTheme.theme)\n                    ? currentTheme.theme.theme\n                    : currentTheme.theme;\n            }\n            if (currentTheme && currentTheme[key]) {\n                theme = Object.assign({}, theme, currentTheme[key]);\n            }\n            if (currentClasses && currentClasses[key]) {\n                const classKeys = Object.keys(currentClasses[key]);\n                for (let i = 0; i < classKeys.length; i++) {\n                    const classKey = classKeys[i];\n                    if (theme[classKey]) {\n                        theme[classKey] = `${theme[classKey]} ${currentClasses[key][classKey].join(' ')}`;\n                    }\n                }\n            }\n            icache.set(css, theme, false);\n            return theme;\n        },\n        variant() {\n            const theme = getTheme();\n            if (theme && isThemeWithVariant(theme)) {\n                return theme.variant.value.root;\n            }\n        },\n        set,\n        get() {\n            const currentTheme = injector.get(INJECTED_THEME_KEY);\n            if (currentTheme) {\n                return currentTheme.get();\n            }\n        }\n    };\n});\nexport default theme;\n//# sourceMappingURL=theme.mjs.map","import { create } from '@dojo/framework/core/vdom';\nimport coreTheme from '@dojo/framework/core/middleware/theme';\nimport { isThemeInjectorPayloadWithVariant } from '@dojo/framework/core/ThemeInjector';\nconst factory = create({ coreTheme });\nexport const THEME_KEY = ' _key';\nfunction uppercaseFirstChar(value) {\n    return `${value.charAt(0).toUpperCase()}${value.slice(1)}`;\n}\nfunction lowercaseFirstChar(value) {\n    return `${value.charAt(0).toLowerCase()}${value.slice(1)}`;\n}\nfunction isThemeWithVariant(theme) {\n    return theme && theme.hasOwnProperty('variant');\n}\nexport const theme = factory(function ({ middleware: { coreTheme }, properties }) {\n    function getTheme() {\n        const { theme } = properties();\n        if (theme) {\n            return theme;\n        }\n        const themePayload = coreTheme.get();\n        if (isThemeInjectorPayloadWithVariant(themePayload)) {\n            return { theme: themePayload.theme, variant: themePayload.variant };\n        }\n        else if (themePayload) {\n            return themePayload.theme;\n        }\n    }\n    return Object.assign({ compose: (baseCss, css, prefix) => {\n            const theme = getTheme();\n            const baseKey = baseCss[THEME_KEY];\n            const variantKey = css[THEME_KEY];\n            const virtualCss = Object.keys(baseCss).reduce((virtualCss, key) => {\n                if (key === THEME_KEY) {\n                    return virtualCss;\n                }\n                if (prefix && !virtualCss[`${prefix}${uppercaseFirstChar(key)}`]) {\n                    virtualCss[`${prefix}${uppercaseFirstChar(key)}`] = ' ';\n                }\n                if (!css[key]) {\n                    virtualCss[key] = ' ';\n                }\n                return virtualCss;\n            }, { [THEME_KEY]: variantKey });\n            const virtualTheme = coreTheme.classes(virtualCss);\n            const variantTheme = coreTheme.classes(css);\n            let baseTheme = coreTheme.classes(baseCss);\n            if (prefix) {\n                const prefixedCss = Object.keys(Object.assign({}, virtualTheme, variantTheme)).reduce((prefixCss, key) => {\n                    if (key.indexOf(prefix) === 0 && key !== prefix) {\n                        const classKey = lowercaseFirstChar(key.replace(prefix, ''));\n                        if (!variantTheme[key] &&\n                            virtualTheme[key] &&\n                            virtualTheme[key].trim()) {\n                            prefixCss[classKey] = `${baseTheme[classKey]} ${virtualTheme[key].trim()}`;\n                        }\n                        if (variantTheme[key]) {\n                            prefixCss[classKey] = variantTheme[key];\n                        }\n                    }\n                    return prefixCss;\n                }, {});\n                baseTheme = Object.assign({}, baseTheme, prefixedCss);\n                if (isThemeWithVariant(theme)) {\n                    return {\n                        theme: {\n                            theme: Object.assign({}, theme.theme.theme, { [baseKey]: baseTheme }),\n                            variants: theme.theme.variants\n                        },\n                        variant: theme.variant\n                    };\n                }\n                return Object.assign({}, theme, { [baseKey]: baseTheme });\n            }\n            const constructedTheme = Object.keys(baseTheme).reduce((theme, key) => {\n                if (key === THEME_KEY) {\n                    return theme;\n                }\n                const variantComposesClass = variantTheme[key] && variantTheme[key].trim();\n                if (variantTheme[key]) {\n                    theme[key] = variantComposesClass;\n                }\n                else if (virtualTheme[key] && virtualTheme[key].trim()) {\n                    theme[key] = `${theme[key]} ${virtualTheme[key].trim()}`;\n                }\n                return theme;\n            }, Object.assign({}, baseTheme));\n            if (isThemeWithVariant(theme)) {\n                return {\n                    theme: {\n                        theme: Object.assign({}, theme.theme.theme, { [baseKey]: constructedTheme }),\n                        variants: theme.theme.variants\n                    },\n                    variant: theme.variant\n                };\n            }\n            return Object.assign({}, theme, { [baseKey]: constructedTheme });\n        } }, coreTheme);\n});\nexport default theme;\n\n/*# sourceMappingURL=theme.mjs.map*/","import { focus } from '@dojo/framework/core/middleware/focus';\nimport { create, tsx } from '@dojo/framework/core/vdom';\nimport { formatAriaProperties } from '../common/util';\nimport { theme } from '../middleware/theme';\nimport * as css from '../theme/default/button.m.css';\nconst factory = create({ focus, theme }).properties();\nexport const Button = factory(function Button({ children, id, middleware: { focus, theme }, properties }) {\n    const { aria = {}, disabled, widgetId, name, pressed, type = 'button', value, onClick, onOut, onOver, onDown, onUp, onBlur, onFocus, title } = properties();\n    const themeCss = theme.classes(css);\n    const idBase = widgetId || `button-${id}`;\n    return (tsx(\"button\", Object.assign({ classes: [\n            theme.variant(),\n            themeCss.root,\n            disabled ? themeCss.disabled : null,\n            pressed ? themeCss.pressed : null\n        ], title: title, disabled: disabled, id: idBase, focus: focus.shouldFocus(), name: name, type: type, value: value, onblur: () => onBlur && onBlur(), onclick: (event) => {\n            event.stopPropagation();\n            onClick && onClick();\n        }, onfocus: () => onFocus && onFocus(), onpointerenter: () => onOver && onOver(), onpointerleave: () => onOut && onOut(), onpointerdown: () => onDown && onDown(), onpointerup: () => onUp && onUp() }, formatAriaProperties(aria), { \"aria-pressed\": typeof pressed === 'boolean' ? pressed.toString() : null }),\n        tsx(\"span\", { classes: themeCss.label }, children())));\n});\nexport default Button;\n\n/*# sourceMappingURL=index.mjs.map*/","import { create, tsx } from \"@dojo/framework/core/vdom\";\r\nimport Button, { ButtonProperties } from \"@dojo/widgets/button\";\r\n\r\nconst factory = create().properties<ButtonProperties>();\r\n\r\nexport default factory(({ properties }) => {\r\n    return <Button {...properties()}>Dojo</Button>;\r\n});\r\n"],"sourceRoot":""}